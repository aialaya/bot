import { AdapterBlueprint } from '@reown/appkit/adapters';
import { ConstantsUtil as CommonConstantsUtil } from '@reown/appkit-common';
import { CoreHelperUtil } from '@reown/appkit-core';
import { ConstantsUtil, PresetsUtil } from '@reown/appkit-utils';
import { EthersHelpersUtil } from '@reown/appkit-utils/ethers';
import { WcConstantsUtil, WcHelpersUtil } from '@reown/appkit';
import UniversalProvider from '@walletconnect/universal-provider';
import * as ethers from 'ethers';
import { CoinbaseWalletSDK } from '@coinbase/wallet-sdk';
import { Ethers5Methods } from './utils/Ethers5Methods.js';
import { formatEther } from 'ethers/lib/utils.js';
import { ProviderUtil } from '@reown/appkit/store';
export class Ethers5Adapter extends AdapterBlueprint {
    constructor() {
        super({});
        this.adapterType = 'ethers';
        this.providerHandlers = null;
        this.namespace = CommonConstantsUtil.CHAIN.EVM;
    }
    createEthersConfig(options) {
        if (!options.metadata) {
            return undefined;
        }
        let injectedProvider = undefined;
        let coinbaseProvider = undefined;
        function getInjectedProvider() {
            if (injectedProvider) {
                return injectedProvider;
            }
            if (typeof window === 'undefined') {
                return undefined;
            }
            if (!window.ethereum) {
                return undefined;
            }
            injectedProvider = window.ethereum;
            return injectedProvider;
        }
        function getCoinbaseProvider() {
            if (coinbaseProvider) {
                return coinbaseProvider;
            }
            if (typeof window === 'undefined') {
                return undefined;
            }
            const coinbaseWallet = new CoinbaseWalletSDK({
                appName: options?.metadata?.name,
                appLogoUrl: options?.metadata?.icons[0],
                appChainIds: options.networks?.map(caipNetwork => caipNetwork.id) || [1, 84532]
            });
            coinbaseProvider = coinbaseWallet.makeWeb3Provider({
                options: options.coinbasePreference ?? 'all'
            });
            return coinbaseProvider;
        }
        const providers = { metadata: options.metadata };
        if (options.enableInjected !== false) {
            providers.injected = getInjectedProvider();
        }
        if (options.enableCoinbase !== false) {
            providers.coinbase = getCoinbaseProvider();
        }
        providers.EIP6963 = options.enableEIP6963 !== false;
        return providers;
    }
    async signMessage(params) {
        const { message, address, provider } = params;
        if (!provider) {
            throw new Error('Provider is undefined');
        }
        try {
            const signature = await Ethers5Methods.signMessage(message, provider, address);
            return { signature };
        }
        catch (error) {
            throw new Error('EthersAdapter:signMessage - Sign message failed');
        }
    }
    async sendTransaction(params) {
        if (!params.provider) {
            throw new Error('Provider is undefined');
        }
        const tx = await Ethers5Methods.sendTransaction({
            value: params.value,
            to: params.to,
            data: params.data,
            gas: params.gas,
            gasPrice: params.gasPrice,
            address: params.address
        }, params.provider, params.address, Number(params.caipNetwork?.id));
        return { hash: tx };
    }
    async writeContract(params) {
        if (!params.provider) {
            throw new Error('Provider is undefined');
        }
        const result = await Ethers5Methods.writeContract(params, params.provider, params.caipAddress, Number(params.caipNetwork?.id));
        return { hash: result };
    }
    async estimateGas(params) {
        const { provider, caipNetwork, address } = params;
        if (!provider) {
            throw new Error('Provider is undefined');
        }
        try {
            const result = await Ethers5Methods.estimateGas({
                data: params.data,
                to: params.to,
                address: address
            }, provider, address, Number(caipNetwork?.id));
            return { gas: result };
        }
        catch (error) {
            throw new Error('EthersAdapter:estimateGas - Estimate gas failed');
        }
    }
    async getEnsAddress(params) {
        const { name, caipNetwork } = params;
        if (caipNetwork) {
            const result = await Ethers5Methods.getEnsAddress(name, caipNetwork);
            return { address: result };
        }
        return { address: '' };
    }
    parseUnits(params) {
        return Ethers5Methods.parseUnits(params.value, params.decimals);
    }
    formatUnits(params) {
        return Ethers5Methods.formatUnits(params.value, params.decimals);
    }
    async syncConnection(params) {
        const { id, chainId } = params;
        const connector = this.connectors.find(c => c.id === id);
        const selectedProvider = connector?.provider;
        if (!selectedProvider) {
            throw new Error('Provider not found');
        }
        const accounts = await selectedProvider.request({
            method: 'eth_requestAccounts'
        });
        const requestChainId = await selectedProvider.request({
            method: 'eth_chainId'
        });
        this.listenProviderEvents(selectedProvider);
        if (!accounts[0]) {
            throw new Error('No accounts found');
        }
        if (!connector?.type) {
            throw new Error('Connector type not found');
        }
        return {
            address: accounts[0],
            chainId: Number(requestChainId) || Number(chainId),
            provider: selectedProvider,
            type: connector.type,
            id
        };
    }
    syncConnectors(options) {
        this.ethersConfig = this.createEthersConfig(options);
        if (this.ethersConfig?.EIP6963) {
            this.listenInjectedConnector(true);
        }
        const connectors = Object.keys(this.ethersConfig || {}).filter(key => key !== 'metadata' && key !== 'EIP6963');
        connectors.forEach(connector => {
            const key = connector === 'coinbase' ? 'coinbaseWalletSDK' : connector;
            const injectedConnector = connector === CommonConstantsUtil.CONNECTOR_ID.INJECTED;
            if (this.namespace) {
                this.addConnector({
                    id: key,
                    explorerId: PresetsUtil.ConnectorExplorerIds[key],
                    imageUrl: options?.connectorImages?.[key],
                    name: PresetsUtil.ConnectorNamesMap[key],
                    imageId: PresetsUtil.ConnectorImageIds[key],
                    type: PresetsUtil.ConnectorTypesMap[key] ?? 'EXTERNAL',
                    info: injectedConnector ? undefined : { rdns: key },
                    chain: this.namespace,
                    chains: [],
                    provider: this.ethersConfig?.[connector]
                });
            }
        });
    }
    async connectWalletConnect(onUri) {
        const connector = this.connectors.find(c => c.type === 'WALLET_CONNECT');
        const provider = connector?.provider;
        if (!this.caipNetworks || !provider) {
            throw new Error('UniversalAdapter:connectWalletConnect - caipNetworks or provider is undefined');
        }
        provider.on('display_uri', (uri) => {
            onUri(uri);
        });
        const namespaces = WcHelpersUtil.createNamespaces(this.caipNetworks);
        await provider.connect({ optionalNamespaces: namespaces });
    }
    eip6963EventHandler(event) {
        if (event.detail) {
            const { info, provider } = event.detail;
            const existingConnector = this.connectors?.find(c => c.name === info?.name);
            if (!existingConnector) {
                const type = PresetsUtil.ConnectorTypesMap[CommonConstantsUtil.CONNECTOR_ID.EIP6963];
                if (type && this.namespace) {
                    this.addConnector({
                        id: info?.rdns || '',
                        type,
                        imageUrl: info?.icon,
                        name: info?.name,
                        provider,
                        info,
                        chain: this.namespace,
                        chains: []
                    });
                }
            }
        }
    }
    listenInjectedConnector(enableEIP6963) {
        if (typeof window !== 'undefined' && enableEIP6963) {
            const handler = this.eip6963EventHandler.bind(this);
            window.addEventListener(ConstantsUtil.EIP6963_ANNOUNCE_EVENT, handler);
            window.dispatchEvent(new Event(ConstantsUtil.EIP6963_REQUEST_EVENT));
        }
    }
    async connect({ id, type, chainId }) {
        const connector = this.connectors.find(c => c.id === id);
        const selectedProvider = connector?.provider;
        if (!selectedProvider) {
            throw new Error('Provider not found');
        }
        let accounts = [];
        let requestChainId = undefined;
        if (type === 'AUTH') {
            const { address } = await selectedProvider.connect({
                chainId
            });
            accounts = [address];
        }
        else {
            accounts = await selectedProvider.request({
                method: 'eth_requestAccounts'
            });
            requestChainId = await selectedProvider.request({
                method: 'eth_chainId'
            });
            this.listenProviderEvents(selectedProvider);
        }
        return {
            address: accounts[0],
            chainId: Number(requestChainId) || Number(chainId),
            provider: selectedProvider,
            type: type,
            id
        };
    }
    async getAccounts(params) {
        const connector = this.connectors.find(c => c.id === params.id);
        const selectedProvider = connector?.provider;
        if (!selectedProvider || !connector) {
            throw new Error('Provider not found');
        }
        if (params.id === CommonConstantsUtil.CONNECTOR_ID.AUTH) {
            const provider = connector['provider'];
            const { address, accounts } = await provider.connect();
            return Promise.resolve({
                accounts: (accounts || [{ address, type: 'eoa' }]).map(account => CoreHelperUtil.createAccount('eip155', account.address, account.type))
            });
        }
        const accounts = await selectedProvider.request({
            method: 'eth_requestAccounts'
        });
        return {
            accounts: accounts.map(account => CoreHelperUtil.createAccount('eip155', account, 'eoa'))
        };
    }
    async reconnect(params) {
        const { id, chainId } = params;
        const connector = this.connectors.find(c => c.id === id);
        if (connector && connector.type === 'AUTH' && chainId) {
            await connector.provider.connect({ chainId });
        }
    }
    async disconnect(params) {
        if (!params.provider || !params.providerType) {
            throw new Error('Provider or providerType not provided');
        }
        switch (params.providerType) {
            case 'WALLET_CONNECT':
                if (params.provider.session) {
                    ;
                    params.provider.disconnect();
                }
                break;
            case 'AUTH':
                await params.provider.disconnect();
                break;
            case 'ANNOUNCED':
            case 'EXTERNAL':
                await this.revokeProviderPermissions(params.provider);
                break;
            default:
                throw new Error('Unsupported provider type');
        }
    }
    async getBalance(params) {
        const caipNetwork = this.caipNetworks?.find((c) => c.id === params.chainId);
        if (caipNetwork) {
            const jsonRpcProvider = new ethers.providers.JsonRpcProvider(caipNetwork.rpcUrls.default.http[0], {
                chainId: caipNetwork.id,
                name: caipNetwork.name
            });
            if (jsonRpcProvider) {
                try {
                    const balance = await jsonRpcProvider.getBalance(params.address);
                    const formattedBalance = formatEther(balance);
                    return { balance: formattedBalance, symbol: caipNetwork.nativeCurrency.symbol };
                }
                catch (error) {
                    return { balance: '', symbol: '' };
                }
            }
        }
        return { balance: '', symbol: '' };
    }
    async getProfile(params) {
        if (params.chainId === 1) {
            const ensProvider = new ethers.providers.InfuraProvider('mainnet');
            const name = await ensProvider.lookupAddress(params.address);
            const avatar = await ensProvider.getAvatar(params.address);
            return { profileName: name || undefined, profileImage: avatar || undefined };
        }
        return { profileName: undefined, profileImage: undefined };
    }
    listenProviderEvents(provider) {
        const disconnectHandler = () => {
            this.removeProviderListeners(provider);
            this.emit('disconnect');
        };
        const accountsChangedHandler = (accounts) => {
            if (accounts.length > 0) {
                this.emit('accountChanged', {
                    address: accounts[0]
                });
            }
        };
        const chainChangedHandler = (chainId) => {
            const chainIdNumber = typeof chainId === 'string' ? EthersHelpersUtil.hexStringToNumber(chainId) : Number(chainId);
            this.emit('switchNetwork', { chainId: chainIdNumber });
        };
        provider.on('disconnect', disconnectHandler);
        provider.on('accountsChanged', accountsChangedHandler);
        provider.on('chainChanged', chainChangedHandler);
        this.providerHandlers = {
            disconnect: disconnectHandler,
            accountsChanged: accountsChangedHandler,
            chainChanged: chainChangedHandler
        };
    }
    removeProviderListeners(provider) {
        if (this.providerHandlers) {
            provider.removeListener('disconnect', this.providerHandlers.disconnect);
            provider.removeListener('accountsChanged', this.providerHandlers.accountsChanged);
            provider.removeListener('chainChanged', this.providerHandlers.chainChanged);
            this.providerHandlers = null;
        }
    }
    async switchNetwork(params) {
        const { caipNetwork, provider, providerType } = params;
        if (providerType === 'WALLET_CONNECT') {
            ;
            provider.setDefaultChain(String(`eip155:${String(caipNetwork.id)}`));
        }
        else if (providerType === 'AUTH') {
            const authProvider = provider;
            await authProvider.switchNetwork(caipNetwork.id);
            await authProvider.connect({
                chainId: caipNetwork.id
            });
        }
        else {
            try {
                await provider.request({
                    method: 'wallet_switchEthereumChain',
                    params: [{ chainId: EthersHelpersUtil.numberToHexString(caipNetwork.id) }]
                });
            }
            catch (switchError) {
                if (switchError.code === WcConstantsUtil.ERROR_CODE_UNRECOGNIZED_CHAIN_ID ||
                    switchError.code === WcConstantsUtil.ERROR_CODE_DEFAULT ||
                    switchError?.data?.originalError?.code ===
                        WcConstantsUtil.ERROR_CODE_UNRECOGNIZED_CHAIN_ID) {
                    await EthersHelpersUtil.addEthereumChain(provider, caipNetwork);
                }
                else if (providerType === 'ANNOUNCED' ||
                    providerType === 'EXTERNAL' ||
                    providerType === 'INJECTED') {
                    throw new Error('Chain is not supported');
                }
            }
        }
    }
    getWalletConnectProvider() {
        return this.connectors.find(c => c.type === 'WALLET_CONNECT')?.provider;
    }
    async revokeProviderPermissions(provider) {
        try {
            const permissions = await provider.request({
                method: 'wallet_getPermissions'
            });
            const ethAccountsPermission = permissions.find(permission => permission.parentCapability === 'eth_accounts');
            if (ethAccountsPermission) {
                await provider.request({
                    method: 'wallet_revokePermissions',
                    params: [{ eth_accounts: {} }]
                });
            }
        }
        catch (error) {
            console.info('Could not revoke permissions from wallet. Disconnecting...', error);
        }
    }
    async getCapabilities(params) {
        const provider = ProviderUtil.getProvider(CommonConstantsUtil.CHAIN.EVM);
        if (!provider) {
            throw new Error('Provider is undefined');
        }
        const walletCapabilitiesString = provider.session?.sessionProperties?.['capabilities'];
        if (walletCapabilitiesString) {
            const walletCapabilities = Ethers5Methods.parseWalletCapabilities(walletCapabilitiesString);
            const accountCapabilities = walletCapabilities[params];
            if (accountCapabilities) {
                return accountCapabilities;
            }
        }
        return await provider.request({ method: 'wallet_getCapabilities', params: [params] });
    }
    async grantPermissions(params) {
        const provider = ProviderUtil.getProvider(CommonConstantsUtil.CHAIN.EVM);
        if (!provider) {
            throw new Error('Provider is undefined');
        }
        return await provider.request({ method: 'wallet_grantPermissions', params });
    }
    async revokePermissions(params) {
        const provider = ProviderUtil.getProvider(CommonConstantsUtil.CHAIN.EVM);
        if (!provider) {
            throw new Error('Provider is undefined');
        }
        return await provider.request({ method: 'wallet_revokePermissions', params: [params] });
    }
}
//# sourceMappingURL=client.js.map