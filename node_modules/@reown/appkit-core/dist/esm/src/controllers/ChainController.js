import { proxyMap, subscribeKey as subKey } from 'valtio/vanilla/utils';
import { proxy, ref, subscribe as sub } from 'valtio/vanilla';
import { AccountController } from './AccountController.js';
import { PublicStateController } from './PublicStateController.js';
import { NetworkUtil } from '@reown/appkit-common';
import { CoreHelperUtil } from '../utils/CoreHelperUtil.js';
import { ConstantsUtil } from '../utils/ConstantsUtil.js';
import { ModalController } from './ModalController.js';
import { EventsController } from './EventsController.js';
import { RouterController } from './RouterController.js';
import { StorageUtil } from '../utils/StorageUtil.js';
import { OptionsController } from './OptionsController.js';
import { ConnectionController } from './ConnectionController.js';
// -- Constants ----------------------------------------- //
const accountState = {
    currentTab: 0,
    tokenBalance: [],
    smartAccountDeployed: false,
    addressLabels: new Map(),
    allAccounts: []
};
const networkState = {
    supportsAllNetworks: true,
    smartAccountEnabledNetworks: []
};
// -- State --------------------------------------------- //
const state = proxy({
    chains: proxyMap(),
    activeCaipAddress: undefined,
    activeChain: undefined,
    activeCaipNetwork: undefined,
    noAdapters: false,
    universalAdapter: {
        networkControllerClient: undefined,
        connectionControllerClient: undefined
    }
});
// -- Controller ---------------------------------------- //
export const ChainController = {
    state,
    subscribe(callback) {
        return sub(state, () => {
            callback(state);
        });
    },
    subscribeKey(key, callback) {
        return subKey(state, key, callback);
    },
    subscribeChainProp(property, callback, chain) {
        let prev = undefined;
        return sub(state.chains, () => {
            const activeChain = chain || state.activeChain;
            if (activeChain) {
                const nextValue = state.chains.get(activeChain)?.[property];
                if (prev !== nextValue) {
                    prev = nextValue;
                    callback(nextValue);
                }
            }
        });
    },
    initialize(adapters, caipNetworks) {
        const { chainId: activeChainId, namespace: activeNamespace } = StorageUtil.getActiveNetworkProps();
        const activeCaipNetwork = caipNetworks?.find(network => network.id.toString() === activeChainId?.toString());
        const defaultAdapter = adapters.find(adapter => adapter?.namespace === activeNamespace);
        const adapterToActivate = defaultAdapter || adapters?.[0];
        if (adapters?.length === 0 || !adapterToActivate) {
            state.noAdapters = true;
        }
        if (!state.noAdapters) {
            state.activeChain = adapterToActivate?.namespace;
            state.activeCaipNetwork = activeCaipNetwork;
            if (state.activeChain) {
                PublicStateController.set({ activeChain: adapterToActivate?.namespace });
            }
            adapters.forEach((adapter) => {
                state.chains.set(adapter.namespace, {
                    namespace: adapter.namespace,
                    connectionControllerClient: adapter.connectionControllerClient,
                    networkControllerClient: adapter.networkControllerClient,
                    adapterType: adapter.adapterType,
                    accountState,
                    networkState,
                    caipNetworks: adapter.caipNetworks
                });
            });
        }
    },
    setAdapterNetworkState(chain, props) {
        const chainAdapter = state.chains.get(chain);
        if (chainAdapter) {
            chainAdapter.networkState = ref({
                ...chainAdapter.networkState,
                ...props
            });
            state.chains.set(chain, ref(chainAdapter));
        }
    },
    setChainAccountData(chain, accountProps, _unknown = true) {
        if (!chain) {
            throw new Error('Chain is required to update chain account data');
        }
        const chainAdapter = state.chains.get(chain);
        if (chainAdapter) {
            chainAdapter.accountState = ref({
                ...chainAdapter.accountState,
                ...accountProps
            });
            state.chains.set(chain, chainAdapter);
            if (state.chains.size === 1 || state.activeChain === chain) {
                if (accountProps.caipAddress) {
                    state.activeCaipAddress = accountProps.caipAddress;
                }
                AccountController.replaceState(chainAdapter.accountState);
            }
        }
    },
    // eslint-disable-next-line max-params
    setAccountProp(prop, value, chain, replaceState = true) {
        this.setChainAccountData(chain, {
            [prop]: value
        }, replaceState);
    },
    setActiveNamespace(chain) {
        state.activeChain = chain;
        const newAdapter = chain ? state.chains.get(chain) : undefined;
        const caipNetwork = newAdapter?.networkState?.caipNetwork;
        if (caipNetwork?.id && chain) {
            state.activeCaipAddress = newAdapter?.accountState?.caipAddress;
            state.activeCaipNetwork = caipNetwork;
            StorageUtil.setActiveCaipNetworkId(caipNetwork?.caipNetworkId);
            PublicStateController.set({
                activeChain: chain,
                selectedNetworkId: caipNetwork?.caipNetworkId
            });
        }
    },
    setActiveCaipNetwork(caipNetwork) {
        if (!caipNetwork) {
            return;
        }
        const newAdapter = state.chains.get(caipNetwork.chainNamespace);
        state.activeChain = caipNetwork.chainNamespace;
        state.activeCaipNetwork = caipNetwork;
        if (newAdapter?.accountState?.address) {
            state.activeCaipAddress = `${caipNetwork.chainNamespace}:${caipNetwork.id}:${newAdapter?.accountState?.address}`;
        }
        else {
            state.activeCaipAddress = undefined;
        }
        if (newAdapter) {
            AccountController.replaceState(newAdapter.accountState);
        }
        PublicStateController.set({
            activeChain: state.activeChain,
            selectedNetworkId: state.activeCaipNetwork?.caipNetworkId
        });
        StorageUtil.setActiveCaipNetworkId(caipNetwork.caipNetworkId);
        const isSupported = this.checkIfSupportedNetwork(caipNetwork.chainNamespace);
        if (!isSupported && !OptionsController.state.allowUnsupportedChain) {
            this.showUnsupportedChainUI();
        }
    },
    addCaipNetwork(caipNetwork) {
        if (!caipNetwork) {
            return;
        }
        const chain = state.chains.get(caipNetwork.chainNamespace);
        if (chain) {
            chain?.caipNetworks?.push(caipNetwork);
        }
    },
    async switchActiveNetwork(network) {
        const activeAdapter = ChainController.state.chains.get(ChainController.state.activeChain);
        const unsupportedNetwork = !activeAdapter?.caipNetworks?.some(caipNetwork => caipNetwork.id === state.activeCaipNetwork?.id);
        const networkControllerClient = this.getNetworkControllerClient(network.chainNamespace);
        if (networkControllerClient) {
            await networkControllerClient.switchCaipNetwork(network);
        }
        if (unsupportedNetwork) {
            RouterController.goBack();
        }
        this.setActiveCaipNetwork(network);
        if (network) {
            EventsController.sendEvent({
                type: 'track',
                event: 'SWITCH_NETWORK',
                properties: { network: network.caipNetworkId }
            });
        }
    },
    setActiveConnector(connector) {
        if (connector) {
            state.activeConnector = ref(connector);
        }
    },
    getNetworkControllerClient(chainNamespace) {
        const chain = chainNamespace || state.activeChain;
        const chainAdapter = state.chains.get(chain);
        if (!chainAdapter) {
            throw new Error('Chain adapter not found');
        }
        if (!chainAdapter.networkControllerClient) {
            throw new Error('NetworkController client not set');
        }
        return chainAdapter.networkControllerClient;
    },
    getConnectionControllerClient(_chain) {
        const chain = _chain || state.activeChain;
        if (!chain) {
            throw new Error('Chain is required to get connection controller client');
        }
        const chainAdapter = state.chains.get(chain);
        if (!chainAdapter?.connectionControllerClient) {
            throw new Error('ConnectionController client not set');
        }
        return chainAdapter.connectionControllerClient;
    },
    getAccountProp(key, _chain) {
        let chain = state.activeChain;
        if (_chain) {
            chain = _chain;
        }
        if (!chain) {
            return undefined;
        }
        const chainAccountState = state.chains.get(chain)?.accountState;
        if (!chainAccountState) {
            return undefined;
        }
        return chainAccountState[key];
    },
    getNetworkProp(key, namespace) {
        const chainNetworkState = state.chains.get(namespace)?.networkState;
        if (!chainNetworkState) {
            return undefined;
        }
        return chainNetworkState[key];
    },
    getRequestedCaipNetworks(chainToFilter) {
        const adapter = state.chains.get(chainToFilter);
        const { approvedCaipNetworkIds = [], requestedCaipNetworks = [] } = adapter?.networkState || {};
        const sortedNetworks = CoreHelperUtil.sortRequestedNetworks(approvedCaipNetworkIds, requestedCaipNetworks);
        return sortedNetworks;
    },
    getAllRequestedCaipNetworks() {
        const requestedCaipNetworks = [];
        state.chains.forEach(chainAdapter => {
            const caipNetworks = this.getRequestedCaipNetworks(chainAdapter.namespace);
            requestedCaipNetworks.push(...caipNetworks);
        });
        return requestedCaipNetworks;
    },
    setRequestedCaipNetworks(requestedNetworks, chain) {
        this.setAdapterNetworkState(chain, { requestedCaipNetworks: requestedNetworks });
    },
    getAllApprovedCaipNetworkIds() {
        const approvedCaipNetworkIds = [];
        state.chains.forEach(chainAdapter => {
            const approvedIds = this.getApprovedCaipNetworkIds(chainAdapter.namespace);
            approvedCaipNetworkIds.push(...approvedIds);
        });
        return approvedCaipNetworkIds;
    },
    getActiveCaipNetwork() {
        return state.activeCaipNetwork;
    },
    getActiveCaipAddress() {
        return state.activeCaipAddress;
    },
    getApprovedCaipNetworkIds(namespace) {
        const adapter = state.chains.get(namespace);
        const approvedCaipNetworkIds = adapter?.networkState?.approvedCaipNetworkIds || [];
        return approvedCaipNetworkIds;
    },
    async setApprovedCaipNetworksData(namespace) {
        const networkControllerClient = this.getNetworkControllerClient();
        const data = await networkControllerClient?.getApprovedCaipNetworksData();
        this.setAdapterNetworkState(namespace, {
            approvedCaipNetworkIds: data?.approvedCaipNetworkIds,
            supportsAllNetworks: data?.supportsAllNetworks
        });
    },
    checkIfSupportedNetwork(namespace) {
        const activeCaipNetwork = this.state.activeCaipNetwork;
        const requestedCaipNetworks = this.getRequestedCaipNetworks(namespace);
        if (!requestedCaipNetworks.length) {
            return true;
        }
        return requestedCaipNetworks?.some(network => network.id === activeCaipNetwork?.id);
    },
    checkIfSupportedChainId(chainId) {
        if (!this.state.activeChain) {
            return true;
        }
        const requestedCaipNetworks = this.getRequestedCaipNetworks(this.state.activeChain);
        return requestedCaipNetworks?.some(network => network.id === chainId);
    },
    // Smart Account Network Handlers
    setSmartAccountEnabledNetworks(smartAccountEnabledNetworks, chain) {
        this.setAdapterNetworkState(chain, { smartAccountEnabledNetworks });
    },
    checkIfSmartAccountEnabled() {
        const networkId = NetworkUtil.caipNetworkIdToNumber(state.activeCaipNetwork?.caipNetworkId);
        const activeChain = this.state.activeChain;
        if (!activeChain || !networkId) {
            return false;
        }
        const smartAccountEnabledNetworks = this.getNetworkProp('smartAccountEnabledNetworks', activeChain);
        return Boolean(smartAccountEnabledNetworks?.includes(Number(networkId)));
    },
    getActiveNetworkTokenAddress() {
        const namespace = this.state.activeCaipNetwork?.chainNamespace || 'eip155';
        const chainId = this.state.activeCaipNetwork?.id || 1;
        const address = ConstantsUtil.NATIVE_TOKEN_ADDRESS[namespace];
        return `${namespace}:${chainId}:${address}`;
    },
    showUnsupportedChainUI() {
        setTimeout(() => {
            ModalController.open({ view: 'UnsupportedChain' });
        }, 300);
    },
    checkIfNamesSupported() {
        const activeCaipNetwork = state.activeCaipNetwork;
        return Boolean(activeCaipNetwork?.chainNamespace &&
            ConstantsUtil.NAMES_SUPPORTED_CHAIN_NAMESPACES.includes(activeCaipNetwork.chainNamespace));
    },
    resetNetwork(namespace) {
        this.setAdapterNetworkState(namespace, {
            approvedCaipNetworkIds: undefined,
            supportsAllNetworks: true,
            smartAccountEnabledNetworks: []
        });
    },
    resetAccount(chain) {
        const chainToWrite = chain;
        if (!chainToWrite) {
            throw new Error('Chain is required to set account prop');
        }
        this.state.activeCaipAddress = undefined;
        this.setChainAccountData(chainToWrite, ref({
            smartAccountDeployed: false,
            currentTab: 0,
            caipAddress: undefined,
            address: undefined,
            balance: undefined,
            balanceSymbol: undefined,
            profileName: undefined,
            profileImage: undefined,
            addressExplorerUrl: undefined,
            tokenBalance: [],
            connectedWalletInfo: undefined,
            preferredAccountType: undefined,
            socialProvider: undefined,
            socialWindow: undefined,
            farcasterUrl: undefined,
            provider: undefined,
            allAccounts: []
        }));
    },
    async disconnect() {
        try {
            const disconnectResults = await Promise.allSettled(Array.from(state.chains.entries()).map(async ([namespace, adapter]) => {
                try {
                    if (adapter.connectionControllerClient?.disconnect) {
                        await adapter.connectionControllerClient.disconnect();
                    }
                    this.resetAccount(namespace);
                    this.resetNetwork(namespace);
                }
                catch (error) {
                    throw new Error(`Failed to disconnect chain ${namespace}: ${error.message}`);
                }
            }));
            const failures = disconnectResults.filter((result) => result.status === 'rejected');
            if (failures.length > 0) {
                throw new Error(failures.map(f => f.reason.message).join(', '));
            }
            StorageUtil.deleteConnectedConnectorId();
            ConnectionController.resetWcConnection();
            EventsController.sendEvent({
                type: 'track',
                event: 'DISCONNECT_SUCCESS'
            });
        }
        catch (error) {
            // eslint-disable-next-line no-console
            console.error(error.message || 'Failed to disconnect chains');
            EventsController.sendEvent({
                type: 'track',
                event: 'DISCONNECT_ERROR',
                properties: {
                    message: error.message || 'Failed to disconnect chains'
                }
            });
        }
    }
};
//# sourceMappingURL=ChainController.js.map