import { ref as qo, onBeforeUnmount as Ho, shallowReadonly as Wo } from "vue";
let it = class An extends Error {
  constructor(e, n, o) {
    super(
      typeof n == "object" ? n.message : n || e,
      {
        cause: typeof n == "object" ? n.cause : o
      }
    ), this.type = e, Object.setPrototypeOf(this, An.prototype);
  }
};
function Rn(t) {
  return t.replace(/[A-Z]/g, (e) => `_${e.toLowerCase()}`);
}
function zo(t) {
  return t.replace(/_[a-z]/g, (e) => e[1].toUpperCase());
}
const Go = "ERR_INVALID_VALUE", Fo = "ERR_UNEXPECTED_VALUE", Jo = "ERR_UNEXPECTED_TYPE", Bn = "ERR_PARSE";
function Pn(t, e) {
  const n = {};
  for (const o in t) {
    const r = t[o];
    if (!r)
      continue;
    let s, a;
    typeof r == "function" ? (s = o, a = r) : [s, a] = r;
    try {
      const i = a(e(s));
      i !== void 0 && (n[o] = i);
    } catch (i) {
      throw new it(
        Bn,
        `Parser for "${o}" property failed${s === o ? "" : `. Source field: "${s}"`}`,
        i
      );
    }
  }
  return n;
}
function Tn(t) {
  let e = t;
  if (typeof e == "string")
    try {
      e = JSON.parse(e);
    } catch (n) {
      throw new it(Go, { cause: n });
    }
  if (typeof e != "object" || !e || Array.isArray(e))
    throw new it(Fo);
  return e;
}
function $(t, e) {
  return (n) => {
    const o = (r) => {
      if (!(n && r === void 0))
        try {
          return e(r);
        } catch (s) {
          throw new it(Bn, {
            message: `"${t}" transformer failed to parse the value`,
            cause: s
          });
        }
    };
    return /* @__PURE__ */ Object.assign(
      o,
      {
        isValid(r) {
          try {
            return o(r), !0;
          } catch {
            return !1;
          }
        }
      }
    );
  };
}
function Mt(t, e) {
  return $(e || "object", (n) => {
    const o = Tn(n);
    return Pn(t, (r) => o[r]);
  });
}
function St(t) {
  throw new it(Jo, `Unexpected value received: ${JSON.stringify(t)}`);
}
const Yo = $("boolean", (t) => {
  if (typeof t == "boolean")
    return t;
  const e = String(t);
  if (e === "1" || e === "true")
    return !0;
  if (e === "0" || e === "false")
    return !1;
  St(t);
}), j = $("string", (t) => {
  if (typeof t == "string" || typeof t == "number")
    return t.toString();
  St(t);
}), Vt = $("number", (t) => {
  if (typeof t == "number")
    return t;
  if (typeof t == "string") {
    const e = Number(t);
    if (!Number.isNaN(e))
      return e;
  }
  St(t);
}), Re = $("date", (t) => t instanceof Date ? t : new Date(Vt()(t) * 1e3));
function kn(t, e) {
  return $(e || "searchParams", (n) => {
    typeof n != "string" && !(n instanceof URLSearchParams) && St(n);
    const o = typeof n == "string" ? new URLSearchParams(n) : n;
    return Pn(t, (r) => {
      const s = o.get(r);
      return s === null ? void 0 : s;
    });
  });
}
function ie(t) {
  for (const e in t)
    t[e] = [Rn(e), t[e]];
  return t;
}
const Qo = (t) => {
  const e = Vt(), n = Vt(!0), o = j(), r = j(!0), s = Yo(!0), a = Mt(ie({
    addedToAttachmentMenu: s,
    allowsWriteToPm: s,
    firstName: o,
    id: e,
    isBot: s,
    isPremium: s,
    languageCode: r,
    lastName: r,
    photoUrl: r,
    username: r
  }), "User")(!0);
  return kn(
    ie({
      authDate: Re(),
      canSendAfter: n,
      chat: Mt(
        ie({
          id: e,
          type: o,
          title: o,
          photoUrl: r,
          username: r
        }),
        "Chat"
      )(!0),
      chatInstance: r,
      chatType: r,
      hash: o,
      queryId: r,
      receiver: a,
      startParam: r,
      user: a
    }),
    "initData"
  )(t);
};
function ct(t) {
  return /^#[\da-f]{6}$/i.test(t);
}
function Ko(t) {
  return /^#[\da-f]{3}$/i.test(t);
}
function On(t) {
  const e = t.replace(/\s/g, "").toLowerCase();
  if (ct(e))
    return e;
  if (Ko(e)) {
    let o = "#";
    for (let r = 0; r < 3; r += 1)
      o += e[1 + r].repeat(2);
    return o;
  }
  const n = e.match(/^rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)$/) || e.match(/^rgba\((\d{1,3}),(\d{1,3}),(\d{1,3}),\d{1,3}\)$/);
  if (!n)
    throw new Error(`Value "${t}" does not satisfy any of known RGB formats.`);
  return n.slice(1).reduce((o, r) => {
    const s = parseInt(r, 10).toString(16);
    return o + (s.length === 1 ? "0" : "") + s;
  }, "#");
}
const Zo = $("rgb", (t) => On(j()(t))), Xo = $(
  "themeParams",
  (t) => {
    const e = Zo(!0);
    return Object.entries(Tn(t)).reduce((n, [o, r]) => (n[zo(o)] = e(r), n), {});
  }
);
// @__NO_SIDE_EFFECTS__
function tr(t) {
  return JSON.stringify(
    Object.fromEntries(
      Object.entries(t).map(([e, n]) => [Rn(e), n])
    )
  );
}
// @__NO_SIDE_EFFECTS__
function Li(t) {
  const { initDataRaw: e, startParam: n, showSettings: o, botInline: r } = t, s = new URLSearchParams();
  return s.set("tgWebAppPlatform", t.platform), s.set("tgWebAppThemeParams", /* @__PURE__ */ tr(t.themeParams)), s.set("tgWebAppVersion", t.version), e && s.set("tgWebAppData", e), n && s.set("tgWebAppStartParam", n), typeof o == "boolean" && s.set("tgWebAppShowSettings", o ? "1" : "0"), typeof r == "boolean" && s.set("tgWebAppBotInline", r ? "1" : "0"), s.toString();
}
function er(t, e) {
  return $("array", (n) => {
    let o;
    if (Array.isArray(n))
      o = n;
    else if (typeof n == "string")
      try {
        const r = JSON.parse(n);
        Array.isArray(r) && (o = r);
      } catch {
      }
    return o || St(n), o.map(t);
  });
}
function Dn(t) {
  return !!t && typeof t == "object" && !Array.isArray(t);
}
function fe(...t) {
  return t.map((e) => {
    if (typeof e == "string")
      return e;
    if (Dn(e))
      return fe(Object.entries(e).map((n) => n[1] && n[0]));
    if (Array.isArray(e))
      return fe(...e);
  }).filter(Boolean).join(" ");
}
function ji(...t) {
  return t.reduce((e, n) => (Dn(n) && Object.entries(n).forEach(([o, r]) => {
    const s = fe(e[o], r);
    s && (e[o] = s);
  }), e), {});
}
let ut = class xn extends Error {
  constructor(e, n, o) {
    super(
      typeof n == "object" ? n.message : n || e,
      {
        cause: typeof n == "object" ? n.cause : o
      }
    ), this.type = e, Object.setPrototypeOf(this, xn.prototype);
  }
};
function Mn(t) {
  return t.replace(/[A-Z]/g, (e) => `_${e.toLowerCase()}`);
}
function nr(t) {
  return t.replace(/_[a-z]/g, (e) => e[1].toUpperCase());
}
const or = "ERR_INVALID_VALUE", rr = "ERR_UNEXPECTED_VALUE", sr = "ERR_UNEXPECTED_TYPE", Vn = "ERR_PARSE";
function In(t, e) {
  const n = {};
  for (const o in t) {
    const r = t[o];
    if (!r)
      continue;
    let s, a;
    typeof r == "function" ? (s = o, a = r) : [s, a] = r;
    try {
      const i = a(e(s));
      i !== void 0 && (n[o] = i);
    } catch (i) {
      throw new ut(
        Vn,
        `Parser for "${o}" property failed${s === o ? "" : `. Source field: "${s}"`}`,
        i
      );
    }
  }
  return n;
}
function Nn(t) {
  let e = t;
  if (typeof e == "string")
    try {
      e = JSON.parse(e);
    } catch (n) {
      throw new ut(or, { cause: n });
    }
  if (typeof e != "object" || !e || Array.isArray(e))
    throw new ut(rr);
  return e;
}
function O(t, e) {
  return (n) => {
    const o = (r) => {
      if (!(n && r === void 0))
        try {
          return e(r);
        } catch (s) {
          throw new ut(Vn, {
            message: `"${t}" transformer failed to parse the value`,
            cause: s
          });
        }
    };
    return /* @__PURE__ */ Object.assign(
      o,
      {
        isValid(r) {
          try {
            return o(r), !0;
          } catch {
            return !1;
          }
        }
      }
    );
  };
}
function T(t, e) {
  return O(e || "object", (n) => {
    const o = Nn(n);
    return In(t, (r) => o[r]);
  });
}
function vt(t) {
  throw new ut(sr, `Unexpected value received: ${JSON.stringify(t)}`);
}
const It = O("boolean", (t) => {
  if (typeof t == "boolean")
    return t;
  const e = String(t);
  if (e === "1" || e === "true")
    return !0;
  if (e === "0" || e === "false")
    return !1;
  vt(t);
}), A = O("string", (t) => {
  if (typeof t == "string" || typeof t == "number")
    return t.toString();
  vt(t);
}), pt = O("number", (t) => {
  if (typeof t == "number")
    return t;
  if (typeof t == "string") {
    const e = Number(t);
    if (!Number.isNaN(e))
      return e;
  }
  vt(t);
}), ar = O("date", (t) => t instanceof Date ? t : new Date(pt()(t) * 1e3));
function Ln(t, e) {
  return O(e || "searchParams", (n) => {
    typeof n != "string" && !(n instanceof URLSearchParams) && vt(n);
    const o = typeof n == "string" ? new URLSearchParams(n) : n;
    return In(t, (r) => {
      const s = o.get(r);
      return s === null ? void 0 : s;
    });
  });
}
function ce(t) {
  for (const e in t)
    t[e] = [Mn(e), t[e]];
  return t;
}
const ir = (t) => {
  const e = pt(), n = pt(!0), o = A(), r = A(!0), s = It(!0), a = T(ce({
    addedToAttachmentMenu: s,
    allowsWriteToPm: s,
    firstName: o,
    id: e,
    isBot: s,
    isPremium: s,
    languageCode: r,
    lastName: r,
    photoUrl: r,
    username: r
  }), "User")(!0);
  return Ln(
    ce({
      authDate: ar(),
      canSendAfter: n,
      chat: T(
        ce({
          id: e,
          type: o,
          title: o,
          photoUrl: r,
          username: r
        }),
        "Chat"
      )(!0),
      chatInstance: r,
      chatType: r,
      hash: o,
      queryId: r,
      receiver: a,
      startParam: r,
      user: a
    }),
    "initData"
  )(t);
};
function cr(t) {
  return /^#[\da-f]{6}$/i.test(t);
}
function ur(t) {
  return /^#[\da-f]{3}$/i.test(t);
}
function pr(t) {
  const e = t.replace(/\s/g, "").toLowerCase();
  if (cr(e))
    return e;
  if (ur(e)) {
    let o = "#";
    for (let r = 0; r < 3; r += 1)
      o += e[1 + r].repeat(2);
    return o;
  }
  const n = e.match(/^rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)$/) || e.match(/^rgba\((\d{1,3}),(\d{1,3}),(\d{1,3}),\d{1,3}\)$/);
  if (!n)
    throw new Error(`Value "${t}" does not satisfy any of known RGB formats.`);
  return n.slice(1).reduce((o, r) => {
    const s = parseInt(r, 10).toString(16);
    return o + (s.length === 1 ? "0" : "") + s;
  }, "#");
}
const lr = O("rgb", (t) => pr(A()(t))), dr = O(
  "themeParams",
  (t) => {
    const e = lr(!0);
    return Object.entries(Nn(t)).reduce((n, [o, r]) => (n[nr(o)] = e(r), n), {});
  }
);
// @__NO_SIDE_EFFECTS__
function jn(t) {
  return JSON.stringify(
    Object.fromEntries(
      Object.entries(t).map(([e, n]) => [Mn(e), n])
    )
  );
}
const _r = (t) => {
  const e = A(), n = A(!0), o = It(!0);
  return Ln({
    botInline: ["tgWebAppBotInline", o],
    initData: ["tgWebAppData", ir(!0)],
    initDataRaw: ["tgWebAppData", n],
    platform: ["tgWebAppPlatform", e],
    showSettings: ["tgWebAppShowSettings", o],
    startParam: ["tgWebAppStartParam", n],
    themeParams: ["tgWebAppThemeParams", dr()],
    version: ["tgWebAppVersion", e]
  }, "launchParams")(t);
};
// @__NO_SIDE_EFFECTS__
function fr(t) {
  const { initDataRaw: e, startParam: n, showSettings: o, botInline: r } = t, s = new URLSearchParams();
  return s.set("tgWebAppPlatform", t.platform), s.set("tgWebAppThemeParams", /* @__PURE__ */ jn(t.themeParams)), s.set("tgWebAppVersion", t.version), e && s.set("tgWebAppData", e), n && s.set("tgWebAppStartParam", n), typeof o == "boolean" && s.set("tgWebAppShowSettings", o ? "1" : "0"), typeof r == "boolean" && s.set("tgWebAppBotInline", r ? "1" : "0"), s.toString();
}
const $n = T({
  eventType: A(),
  eventData: (t) => t
}, "miniAppsMessage"), Un = O("fn", (t) => {
  if (typeof t == "function")
    return t;
  vt(t);
});
function hr(t) {
  return !!t && typeof t == "object" && !Array.isArray(t);
}
const mr = T({
  TelegramWebviewProxy: T({ postEvent: Un() })()
});
function qn(t) {
  return mr().isValid(t);
}
function br() {
  try {
    return window.self !== window.top;
  } catch {
    return !0;
  }
}
var gr = Object.defineProperty, wr = (t, e, n) => e in t ? gr(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, Hn = (t, e, n) => wr(t, typeof e != "symbol" ? e + "" : e, n);
let l = class Wn extends Error {
  constructor(e, n, o) {
    super(
      typeof n == "object" ? n.message : n || e,
      {
        cause: typeof n == "object" ? n.cause : o
      }
    ), this.type = e, Object.setPrototypeOf(this, Wn.prototype);
  }
};
function he(t, e, n) {
  return t.addEventListener(e, n), () => t.removeEventListener(e, n);
}
function Z(...t) {
  const e = t.flat(1);
  return [
    e.push.bind(e),
    () => {
      e.forEach((n) => {
        n();
      });
    }
  ];
}
function yr(t, e) {
  return t instanceof l && t.type === e;
}
function Be(t) {
  return (e) => yr(e, t);
}
const zn = "ERR_ABORTED", Gn = "ERR_CANCELED", Fn = "ERR_TIMED_OUT";
function pn(t) {
  return new l(zn, { cause: t });
}
const $i = Be(Fn), Ui = Be(zn), qi = Be(Gn);
function ln(t, e) {
  return t.reject = e.reject, t;
}
class g extends Promise {
  constructor(e, n) {
    let o, r;
    typeof e == "function" ? (o = e, r = n) : r = e;
    let s, a;
    super((i, p) => {
      r || (r = {});
      const { abortSignal: c } = r;
      if (c && c.aborted)
        return p(pn(c.reason));
      const [_, b] = Z(), w = (f) => (...W) => (b(), f(...W)), N = new AbortController(), { signal: S } = N;
      a = w((f) => {
        N.abort(f), p(f);
      }), s = w(i), c && _(
        he(c, "abort", () => {
          a(pn(c.reason));
        })
      );
      const { timeout: m } = r;
      if (m) {
        const f = setTimeout(() => {
          a(new l(Fn, `Timeout reached: ${m}ms`));
        }, m);
        _(() => {
          clearTimeout(f);
        });
      }
      o && o(s, a, S);
    }), Hn(this, "reject"), this.reject = a;
  }
  /**
   * Creates a new BetterPromise instance using executor, resolving promise when a result
   * was returned.
   * @param fn - function returning promise result.
   * @param options - additional options.
   */
  static withFn(e, n) {
    return new g((o, r, s) => {
      try {
        const a = e(s);
        return a instanceof Promise ? a.then(o, r) : o(a);
      } catch (a) {
        r(a);
      }
    }, n);
  }
  /**
   * @see Promise.resolve
   */
  static resolve(e) {
    return new g((n) => {
      n(e);
    });
  }
  /**
   * @see Promise.reject
   */
  static reject(e) {
    return new g((n, o) => {
      o(e);
    });
  }
  /**
   * Cancels the promise execution.
   */
  cancel() {
    this.reject(new l(Gn));
  }
  /**
   * @see Promise.catch
   */
  catch(e) {
    return this.then(void 0, e);
  }
  /**
   * @see Promise.finally
   */
  finally(e) {
    return ln(super.finally(e), this);
  }
  /**
   * @see Promise.then
   */
  then(e, n) {
    return ln(super.then(e, n), this);
  }
}
function dn(t, e) {
  return t.resolve = e.resolve, t;
}
class ot extends g {
  constructor(e, n) {
    let o, r;
    typeof e == "function" ? (o = e, r = n) : r = e;
    let s;
    super((a, i, p) => {
      s = a, o && o(a, i, p);
    }, r), Hn(this, "resolve"), this.resolve = s;
  }
  /**
   * Creates a new EnhancedPromise instance using executor, resolving promise when a result
   * was returned.
   * @param fn - function returning promise result.
   * @param options - additional options.
   */
  static withFn(e, n) {
    return new ot(
      (o, r, s) => g.withFn(e, { abortSignal: s }).then(o, r),
      n
    );
  }
  /**
   * @see Promise.resolve
   */
  static resolve(e) {
    return new ot((n) => {
      n(e);
    });
  }
  /**
   * @see Promise.reject
   */
  static reject(e) {
    return new ot((n, o) => {
      o(e);
    });
  }
  /**
   * @see Promise.catch
   */
  catch(e) {
    return this.then(void 0, e);
  }
  /**
   * @see Promise.finally
   */
  finally(e) {
    return dn(super.finally(e), this);
  }
  /**
   * @see Promise.then
   */
  then(e, n) {
    return dn(super.then(e, n), this);
  }
}
function Er(t, e) {
  return new g((n) => {
    setTimeout(n, t);
  }, { abortSignal: e });
}
function Jn(t) {
  return `tapps/${t}`;
}
function R(t, e) {
  sessionStorage.setItem(Jn(t), JSON.stringify(e));
}
function B(t) {
  const e = sessionStorage.getItem(Jn(t));
  try {
    return e ? JSON.parse(e) : void 0;
  } catch {
  }
}
function Pe(t) {
  return t.replace(/[A-Z]/g, (e) => `-${e.toLowerCase()}`);
}
// @__NO_SIDE_EFFECTS__
function Sr(t, e) {
  e || (e = {});
  const {
    textColor: n,
    bgColor: o,
    shouldLog: r = !0
  } = e;
  function s(a, ...i) {
    if (!r || typeof r == "function" && !r())
      return;
    const p = "font-weight:bold;padding:0 5px;border-radius:5px";
    console[a](
      `%c${Intl.DateTimeFormat("en-GB", {
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit",
        fractionalSecondDigits: 3,
        timeZone: "UTC"
      }).format(/* @__PURE__ */ new Date())}%c / %c${t}`,
      `${p};background-color: lightblue;color:black`,
      "",
      `${p};${n ? `color:${n};` : ""}${o ? `background-color:${o}` : ""}`,
      ...i
    );
  }
  return [
    function(...a) {
      s("log", ...a);
    },
    function(...a) {
      s("error", ...a);
    }
  ];
}
function Te(t, e) {
  document.documentElement.style.setProperty(t, e);
}
function ke(t) {
  document.documentElement.style.removeProperty(t);
}
function vr(t, e) {
  e();
}
// @__NO_SIDE_EFFECTS__
function X(t, e) {
  e || (e = {});
  const n = e.equals || Object.is;
  let o = [], r = t;
  const s = (c) => {
    if (!n(r, c)) {
      const _ = r;
      r = c, vr(p, () => {
        [...o].forEach(([b, w]) => {
          b(c, _), w && i(b, !0);
        });
      });
    }
  };
  function a(c) {
    const _ = typeof c != "object" ? { once: c } : c;
    return {
      once: _.once || !1,
      signal: _.signal || !1
    };
  }
  const i = (c, _) => {
    const b = a(_), w = o.findIndex(([N, S]) => N === c && S.once === b.once && S.signal === b.signal);
    w >= 0 && o.splice(w, 1);
  }, p = Object.assign(
    function() {
      return Cr(p), r;
    },
    {
      destroy() {
        o = [];
      },
      set: s,
      reset() {
        s(t);
      },
      sub(c, _) {
        return o.push([c, a(_)]), () => i(c, _);
      },
      unsub: i,
      unsubAll() {
        o = o.filter((c) => c[1].signal);
      }
    }
  );
  return p;
}
const ue = [];
function Cr(t) {
  ue.length && ue[ue.length - 1].add(t);
}
const Ar = /* @__PURE__ */ X(!1), [Oe, Rr] = /* @__PURE__ */ Sr("Bridge", {
  bgColor: "#9147ff",
  textColor: "white",
  shouldLog: Ar
}), Br = {
  clipboard_text_received: T({
    req_id: A(),
    data: (t) => t === null ? t : A(!0)(t)
  }, "clipboard_text_received"),
  custom_method_invoked: T({
    req_id: A(),
    result: (t) => t,
    error: A(!0)
  }, "custom_method_invoked"),
  popup_closed: O("popup_closed", (t) => t ? T({
    button_id: (e) => e == null ? void 0 : A()(e)
  })()(t) : {}),
  viewport_changed: T({
    height: pt(),
    width: (t) => t == null ? window.innerWidth : pt()(t),
    is_state_stable: It(),
    is_expanded: It()
  }, "viewport_changed")
};
function Pr(t) {
  const e = window, [, n] = Z(
    // Add "resize" event listener to make sure, we always have fresh viewport information.
    // The desktop version of Telegram is sometimes not sending the "viewport_changed"
    // event. For example, when the Main Button is shown. That's why we should
    // add our own listener to make sure viewport information is always fresh.
    // Issue: https://github.com/Telegram-Mini-Apps/telegram-apps/issues/10
    he(e, "resize", () => {
      t(["viewport_changed", {
        width: window.innerWidth,
        height: window.innerHeight,
        is_state_stable: !0,
        is_expanded: !0
      }]);
    }),
    // Add listener, which handles events sent from the Telegram web application and also events
    // generated by the local emitEvent function.
    he(e, "message", (o) => {
      if (o.source !== e.parent)
        return;
      let r;
      try {
        r = $n()(o.data);
      } catch {
        return;
      }
      const { eventType: s, eventData: a } = r, i = Br[s];
      try {
        const p = i ? i()(a) : a;
        Oe("Event received:", p ? { eventType: s, eventData: p } : { eventType: s }), t([s, p]);
      } catch (p) {
        Rr(
          [
            `An error occurred processing the "${s}" event from the Telegram application.`,
            "Please, file an issue here:",
            "https://github.com/Telegram-Mini-Apps/telegram-apps/issues/new/choose"
          ].join(`
`),
          r,
          p
        );
      }
    })
  );
  return n;
}
const me = /* @__PURE__ */ X(), _n = /* @__PURE__ */ X();
function Yn() {
  return _n() || _n.set(Pr(me.set)), me;
}
const pe = /* @__PURE__ */ X({});
function Qn(t) {
  let e = pe()[t];
  return e || (e = /* @__PURE__ */ X(void 0, {
    equals() {
      return !1;
    }
  }), Yn().sub((n) => {
    n && n[0] === t && e.set(n[1]);
  }), pe.set({ ...pe(), [t]: e })), e;
}
function v(t, e, n) {
  return Qn(t).sub(e, n);
}
const Tr = "ERR_METHOD_UNSUPPORTED", kr = "ERR_RETRIEVE_LP_FAILED", Or = "ERR_METHOD_PARAMETER_UNSUPPORTED", Kn = "ERR_UNKNOWN_ENV", Dr = "ERR_INVOKE_CUSTOM_METHOD_RESPONSE", xr = /* @__PURE__ */ X("https://web.telegram.org");
function De(t, e) {
  Oe("Posting event:", e ? { eventType: t, eventData: e } : { eventType: t });
  const n = window;
  if (qn(n)) {
    n.TelegramWebviewProxy.postEvent(t, JSON.stringify(e));
    return;
  }
  const o = JSON.stringify({ eventType: t, eventData: e });
  if (br())
    return n.parent.postMessage(o, xr());
  const { external: r } = n;
  if (T({ notify: Un() })().isValid(r)) {
    r.notify(o);
    return;
  }
  throw new l(Kn);
}
function xe(t, e, n) {
  n || (n = {});
  const { capture: o } = n, [r, s] = Z();
  return new g((a) => {
    (Array.isArray(e) ? e : [e]).forEach((i) => {
      r(
        v(i, (p) => {
          (!o || (Array.isArray(e) ? o({
            event: i,
            payload: p
          }) : o(p))) && a(p);
        })
      );
    }), (n.postEvent || De)(t, n.params);
  }, n).finally(s);
}
function Me(t) {
  return _r()(t);
}
function Zn(t) {
  return Me(
    t.replace(/^[^?#]*[?#]/, "").replace(/[?#]/g, "&")
  );
}
function Mr() {
  return Zn(window.location.href);
}
function Vr() {
  const t = performance.getEntriesByType("navigation")[0];
  if (!t)
    throw new Error("Unable to get first navigation entry.");
  return Zn(t.name);
}
const Ir = "launchParams";
function Nr() {
  return Me(B(Ir) || "");
}
function Xn(t) {
  R("launchParams", /* @__PURE__ */ fr(t));
}
function to(t) {
  return t instanceof Error ? t.message + (t.cause ? `
  ${to(t.cause)}` : "") : JSON.stringify(t);
}
function G() {
  const t = [];
  for (const e of [
    // Try to retrieve launch parameters from the current location. This method can return
    // nothing in case, location was changed, and then the page was reloaded.
    Mr,
    // Then, try using the lower level API - window.performance.
    Vr,
    // Finally, try to extract launch parameters from the session storage.
    Nr
  ])
    try {
      const n = e();
      return Xn(n), n;
    } catch (n) {
      t.push(n);
    }
  throw new l(kr, [
    "Unable to retrieve launch parameters from any known source. Perhaps, you have opened your app outside Telegram?",
    "ðŸ“– Refer to docs for more information:",
    "https://docs.telegram-mini-apps.com/packages/telegram-apps-sdk/environment",
    "Collected errors:",
    ...t.map((e) => `â€” ${to(e)}`)
  ].join(`
`));
}
function fn(t) {
  if (t === "simple")
    try {
      return G(), !0;
    } catch {
      return !1;
    }
  return g.withFn(async () => {
    if (qn(window))
      return !0;
    try {
      return await xe("web_app_request_theme", "theme_changed", { timeout: 100 }), !0;
    } catch {
      return !1;
    }
  }, t);
}
function be(t, e) {
  window.dispatchEvent(new MessageEvent("message", {
    data: JSON.stringify({ eventType: t, eventData: e }),
    // We specify window.parent to imitate the case, the parent iframe sent us this event.
    source: window.parent
  }));
}
function Lr(t, e) {
  if (typeof e == "string")
    try {
      const { eventType: n } = $n()(e);
      n === "web_app_request_theme" && be("theme_changed", {
        theme_params: JSON.parse(/* @__PURE__ */ jn(t))
      }), n === "web_app_request_viewport" && be("viewport_changed", {
        width: window.innerWidth,
        height: window.innerHeight,
        is_state_stable: !0,
        is_expanded: !0
      });
    } catch {
    }
}
function Hi(t) {
  var e;
  const n = typeof t == "string" ? Me(t) : t;
  Xn(n);
  const o = (e = window.TelegramWebviewProxy) == null ? void 0 : e.postEvent;
  window.TelegramWebviewProxy = {
    postEvent(r, s) {
      Lr(n.themeParams, JSON.stringify({ eventType: r, eventData: s })), o == null || o(r, s);
    }
  }, Oe("Environment was mocked by the mockTelegramEnv function");
}
function jr() {
  [
    ["TelegramGameProxy_receiveEvent"],
    // Windows Phone.
    ["TelegramGameProxy", "receiveEvent"],
    // Desktop.
    ["Telegram", "WebView", "receiveEvent"]
    // Android and iOS.
  ].forEach((t) => {
    let e = window;
    t.forEach((n, o, r) => {
      if (o === r.length - 1) {
        e[n] = be;
        return;
      }
      n in e || (e[n] = {}), e = e[n];
    });
  });
}
function $r() {
  ["TelegramGameProxy_receiveEvent", "TelegramGameProxy", "Telegram"].forEach((t) => {
    delete window[t];
  });
}
function F(t, e, n) {
  Qn(t).unsub(e, n);
}
function Wi(t, e) {
  return Yn().sub(t, e);
}
function zi(t, e) {
  me.unsub(t, e);
}
function eo(t) {
  return ({ req_id: e }) => e === t;
}
function hn(t) {
  return t.split(".").map(Number);
}
function Ur(t, e) {
  const n = hn(t), o = hn(e), r = Math.max(n.length, o.length);
  for (let s = 0; s < r; s += 1) {
    const a = n[s] || 0, i = o[s] || 0;
    if (a !== i)
      return a > i ? 1 : -1;
  }
  return 0;
}
function y(t, e) {
  return Ur(t, e) <= 0;
}
function z(t, e, n) {
  if (typeof n == "string") {
    if (t === "web_app_open_link") {
      if (e === "try_instant_view")
        return y("6.4", n);
      if (e === "try_browser")
        return y("7.6", n);
    }
    if (t === "web_app_set_header_color" && e === "color")
      return y("6.9", n);
    if (t === "web_app_close" && e === "return_back")
      return y("7.6", n);
    if (t === "web_app_setup_main_button" && e === "has_shine_effect")
      return y("7.10", n);
  }
  switch (t) {
    case "web_app_open_tg_link":
    case "web_app_open_invoice":
    case "web_app_setup_back_button":
    case "web_app_set_background_color":
    case "web_app_set_header_color":
    case "web_app_trigger_haptic_feedback":
      return y("6.1", e);
    case "web_app_open_popup":
      return y("6.2", e);
    case "web_app_close_scan_qr_popup":
    case "web_app_open_scan_qr_popup":
    case "web_app_read_text_from_clipboard":
      return y("6.4", e);
    case "web_app_switch_inline_query":
      return y("6.7", e);
    case "web_app_invoke_custom_method":
    case "web_app_request_write_access":
    case "web_app_request_phone":
      return y("6.9", e);
    case "web_app_setup_settings_button":
      return y("6.10", e);
    case "web_app_biometry_get_info":
    case "web_app_biometry_open_settings":
    case "web_app_biometry_request_access":
    case "web_app_biometry_request_auth":
    case "web_app_biometry_update_token":
      return y("7.2", e);
    case "web_app_setup_swipe_behavior":
      return y("7.7", e);
    case "web_app_share_to_story":
      return y("7.8", e);
    case "web_app_setup_secondary_button":
    case "web_app_set_bottom_bar_color":
      return y("7.10", e);
    default:
      return [
        "iframe_ready",
        "iframe_will_reload",
        "web_app_close",
        "web_app_data_send",
        "web_app_expand",
        "web_app_open_link",
        "web_app_ready",
        "web_app_request_theme",
        "web_app_request_viewport",
        "web_app_setup_main_button",
        "web_app_setup_closing_behavior"
      ].includes(t);
  }
}
function qr(t, e) {
  e || (e = "strict");
  const n = typeof e == "function" ? e : (o) => {
    const { method: r, version: s } = o;
    let a, i;
    if ("param" in o ? (a = `Parameter "${o.param}" of "${r}" method is unsupported in Mini Apps version ${s}`, i = Or) : (a = `Method "${r}" is unsupported in Mini Apps version ${s}`, i = Tr), e === "strict")
      throw new l(i, a);
    return console.warn(a);
  };
  return (o, r) => z(o, t) ? hr(r) && o === "web_app_set_header_color" && "color" in r && !z(o, "color", t) ? n({ version: t, method: o, param: "color" }) : De(o, r) : n({ version: t, method: o });
}
function Hr(t, e, n, o) {
  return xe("web_app_invoke_custom_method", "custom_method_invoked", {
    ...o || {},
    params: { method: t, params: e, req_id: n },
    capture: eo(n)
  }).then(({ result: r, error: s }) => {
    if (s)
      throw new l(Dr, s);
    return r;
  });
}
function Wr() {
  return performance.getEntriesByType("navigation")[0];
}
function D() {
  const t = Wr();
  return !!t && t.type === "reload";
}
let Y;
function zr(t, e) {
  Y && Y.set(t, e) || e();
}
function Gr(t) {
  if (Y)
    return t();
  Y = /* @__PURE__ */ new Map();
  try {
    t();
  } finally {
    Y.forEach((e) => e()), Y = void 0;
  }
}
// @__NO_SIDE_EFFECTS__
function u(t, e) {
  e || (e = {});
  const n = e.equals || Object.is;
  let o = [], r = t;
  const s = (c) => {
    if (!n(r, c)) {
      const _ = r;
      r = c, zr(p, () => {
        [...o].forEach(([b, w]) => {
          b(c, _), w && i(b, !0);
        });
      });
    }
  };
  function a(c) {
    const _ = typeof c != "object" ? { once: c } : c;
    return {
      once: _.once || !1,
      signal: _.signal || !1
    };
  }
  const i = (c, _) => {
    const b = a(_), w = o.findIndex(([N, S]) => N === c && S.once === b.once && S.signal === b.signal);
    w >= 0 && o.splice(w, 1);
  }, p = Object.assign(
    function() {
      return Fr(p), r;
    },
    {
      destroy() {
        o = [];
      },
      set: s,
      reset() {
        s(t);
      },
      sub(c, _) {
        return o.push([c, a(_)]), () => i(c, _);
      },
      unsub: i,
      unsubAll() {
        o = o.filter((c) => c[1].signal);
      }
    }
  );
  return p;
}
const rt = [];
function Fr(t) {
  rt.length && rt[rt.length - 1].add(t);
}
// @__NO_SIDE_EFFECTS__
function h(t, e) {
  let n = /* @__PURE__ */ new Set(), o;
  function r() {
    return o || (o = /* @__PURE__ */ u(a(), e));
  }
  function s() {
    r().set(a());
  }
  function a() {
    n.forEach((c) => {
      c.unsub(s, { signal: !0 });
    });
    const i = /* @__PURE__ */ new Set();
    let p;
    rt.push(i);
    try {
      p = t();
    } finally {
      rt.pop();
    }
    return i.forEach((c) => {
      c.sub(s, { signal: !0 });
    }), n = i, p;
  }
  return Object.assign(function() {
    return r()();
  }, {
    destroy() {
      r().destroy();
    },
    sub(...i) {
      return r().sub(...i);
    },
    unsub(...i) {
      r().unsub(...i);
    },
    unsubAll(...i) {
      r().unsubAll(...i);
    }
  });
}
const Jr = /* @__PURE__ */ u(/* @__PURE__ */ (() => {
  let t = 0;
  return () => (t += 1).toString();
})()), no = /* @__PURE__ */ u(De), L = /* @__PURE__ */ u("0.0");
function Yr(t) {
  t || (t = {});
  const { postEvent: e } = t, n = t.version || G().version;
  L.set(n), no.set(
    typeof e == "function" ? e : qr(n)
  );
}
function oo() {
  return Jr()();
}
function tt(t, e, n) {
  return Hr(t, e, oo(), {
    ...n || {},
    postEvent: d
  });
}
const x = (t, e, n) => (n || (n = {}), n.postEvent || (n.postEvent = d), xe(t, e, n)), d = (t, e) => no()(t, e);
function M(t) {
  return /* @__PURE__ */ h(() => z(t, L()));
}
const nt = "ERR_POPUP_INVALID_PARAMS", Ve = "ERR_INVALID_URL", Qr = "ERR_INVALID_SLUG", Kr = "ERR_DATA_INVALID_SIZE", Zr = "ERR_ACCESS_DENIED", jt = "ERR_ALREADY_REQUESTING", Ie = "ERR_ALREADY_OPENED", Xr = "ERR_ALREADY_MOUNTING", ts = "ERR_VARS_ALREADY_BOUND", es = "ERR_NOT_AVAILABLE", ns = "ERR_NOT_INITIALIZED", mn = "ERR_NOT_SUPPORTED", os = "ERR_NOT_MOUNTED";
function bn() {
  return typeof window > "u";
}
// @__NO_SIDE_EFFECTS__
function V(t, e, { isSupported: n, isMounted: o, component: r, supports: s } = {}) {
  const a = `${r ? `${r}.` : ""}${t}()`;
  n = n ? Array.isArray(n) || typeof n == "object" && "any" in n ? n : [n] : void 0;
  function i(m) {
    if (s) {
      const f = s[m];
      return z(f[0], f[1], L());
    }
    return !0;
  }
  const p = () => {
    if (!n)
      return;
    const m = `it is unsupported in Mini Apps version ${L()}`;
    function f(C) {
      return typeof C == "string" ? z(C, L()) ? void 0 : m : C.fn() ? void 0 : C.error;
    }
    if (Array.isArray(n)) {
      for (const C of n) {
        const un = f(C);
        if (un)
          return un;
      }
      return;
    }
    let W;
    for (const C of n.any)
      if (W = f(C), !W)
        return;
    return m;
  }, c = (...m) => {
    if (s) {
      for (const f in s)
        if (s[f][2](...m) && !i(f))
          return `option ${f} is not supported in Mini Apps version ${L()}`;
    }
  }, _ = /* @__PURE__ */ h(() => !p()), b = /* @__PURE__ */ h(() => L() !== "0.0"), w = /* @__PURE__ */ h(() => !o || o()), N = /* @__PURE__ */ h(
    () => fn("simple") && !bn() && b() && _() && w()
  );
  let S;
  if (s) {
    S = {};
    for (const m in s)
      S[m] = /* @__PURE__ */ h(() => i(m));
  }
  return Object.assign(
    (...m) => {
      const f = `Unable to call the ${a} ${r ? "method" : "function"}:`;
      if (bn() || !fn("simple"))
        throw new l(
          Kn,
          `${f} it can't be called outside Mini Apps`
        );
      if (!b())
        throw new l(
          ns,
          `${f} the SDK was not initialized. Use the SDK init() function`
        );
      const W = p();
      if (W)
        throw new l(mn, `${f} ${W}`);
      const C = c(...m);
      if (C)
        throw new l(mn, `${f} ${C}`);
      if (!w())
        throw new l(
          os,
          `${f} the component is not mounted. Use the ${r}.mount() method`
        );
      return e(...m);
    },
    e,
    {
      isAvailable: N,
      ifAvailable(...m) {
        return N() ? e(...m) : void 0;
      }
    },
    n ? {
      isSupported: _
    } : {},
    S ? {
      supports: S
    } : {}
  );
}
function $t(t, e) {
  return e || (e = {}), (n, o, r, s) => /* @__PURE__ */ V(n, o, {
    ...e,
    isSupported: r || e.isSupported,
    supports: s,
    component: t
  });
}
function et(t, e, n) {
  return $t(t, { isSupported: n, isMounted: e });
}
function P(t, e) {
  return $t(t, { isSupported: e });
}
const Ut = "web_app_setup_back_button", ro = "back_button_pressed", qt = "backButton", ge = /* @__PURE__ */ u(!1), lt = /* @__PURE__ */ u(!1), rs = M(Ut), so = et(qt, lt, Ut), Ne = P(qt, Ut), ss = so("hide", () => {
  Le(!1);
}), as = Ne("mount", () => {
  lt() || (Le(D() && B(qt) || !1), lt.set(!0));
});
function Le(t) {
  t !== ge() && (d(Ut, { is_visible: t }), R(qt, t), ge.set(t));
}
const is = Ne(
  "onClick",
  (t) => v(ro, t)
), cs = Ne(
  "offClick",
  (t) => {
    F(ro, t);
  }
), us = so("show", () => {
  Le(!0);
});
function ps() {
  lt.set(!1);
}
const Gi = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hide: ss,
  isMounted: lt,
  isSupported: rs,
  isVisible: ge,
  mount: as,
  offClick: cs,
  onClick: is,
  show: us,
  unmount: ps
}, Symbol.toStringTag, { value: "Module" }));
// @__NO_SIDE_EFFECTS__
function ao(t, e, n, {
  isMounting: o,
  isMounted: r,
  mountError: s
}) {
  return (a) => g.withFn(async (i) => {
    if (r())
      return;
    if (o())
      throw new l(
        Xr,
        `The ${t} component is already mounting`
      );
    o.set(!0);
    let p;
    try {
      p = [!0, await e({ abortSignal: i })];
    } catch (c) {
      p = [!1, c];
    }
    Gr(() => {
      if (o.set(!1), r.set(!0), p[0])
        n(p[1]);
      else {
        const c = p[1];
        throw s.set(c), c;
      }
    });
  }, a);
}
const U = $t, Ht = /* @__PURE__ */ u(), Rt = /* @__PURE__ */ u(!1), Bt = /* @__PURE__ */ u(!1), Wt = /* @__PURE__ */ u(!1), io = /* @__PURE__ */ u(!1), co = /* @__PURE__ */ u(void 0), ls = /* @__PURE__ */ h(() => {
  const t = Ht();
  return t && t.available;
});
function je(t) {
  return t.available ? {
    available: !0,
    tokenSaved: t.token_saved,
    deviceId: t.device_id,
    accessRequested: t.access_requested,
    type: t.type,
    accessGranted: t.access_granted
  } : {
    available: !1
  };
}
const gn = "web_app_biometry_get_info", ds = /* @__PURE__ */ V(
  "requestBiometry",
  (t) => x(gn, "biometry_info_received", t).then(je),
  {
    isSupported: gn
  }
), zt = "web_app_biometry_request_auth", _s = "web_app_biometry_request_access", fs = "web_app_biometry_open_settings", hs = "web_app_biometry_update_token", $e = "biometry_info_received", K = "biometry", ms = M(zt), bs = U(K), gs = P(K, zt), Ue = et(K, Wt, zt);
function uo() {
  throw new l(es, "Biometry is not available");
}
const ws = Ue(
  "authenticate",
  (t) => g.withFn(async (e) => {
    if (Rt())
      throw new l(jt, "Authentication is already in progress");
    const n = Ht();
    (!n || !n.available) && uo(), Rt.set(!0);
    try {
      const o = await x(
        zt,
        "biometry_auth_requested",
        {
          abortSignal: e,
          params: {
            reason: ((t || {}).reason || "").trim()
          }
        }
      ), { token: r } = o;
      return typeof r == "string" && Gt({ ...n, token: r }), o;
    } finally {
      Rt.set(!1);
    }
  }, t)
), ys = gs("openSettings", () => {
  d(fs);
}), Es = Ue(
  "requestAccess",
  (t) => g.withFn(async (e) => {
    if (Bt())
      throw new l(jt, "Access request is already in progress");
    Bt.set(!0);
    try {
      const n = await x(_s, $e, {
        abortSignal: e,
        params: { reason: (t || {}).reason || "" }
      }).then(je);
      return n.available || uo(), Gt(n), n.accessGranted;
    } finally {
      Bt.set(!1);
    }
  }, t)
), Ss = bs(
  "mount",
  /* @__PURE__ */ ao(
    K,
    (t) => D() && B(K) || ds(t),
    (t) => {
      v($e, po), Gt(t);
    },
    { isMounted: Wt, mountError: co, isMounting: io }
  )
), po = (t) => {
  Gt(je(t));
};
function Gt(t) {
  Ht.set(t), R(K, t);
}
function vs() {
  F($e, po), Wt.set(!1);
}
const Cs = Ue(
  "updateToken",
  (t) => (t || (t = {}), x(hs, "biometry_token_updated", {
    ...t,
    params: {
      token: t.token || "",
      reason: t.reason
    }
  }).then((e) => e.status))
), Fi = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  authenticate: ws,
  isAuthenticating: Rt,
  isAvailable: ls,
  isMounted: Wt,
  isMounting: io,
  isRequestingAccess: Bt,
  isSupported: ms,
  mount: Ss,
  mountError: co,
  openSettings: ys,
  requestAccess: Es,
  state: Ht,
  unmount: vs,
  updateToken: Cs
}, Symbol.toStringTag, { value: "Module" }));
function Ft(t, e) {
  return $t(t, { isMounted: e });
}
const Jt = "closingBehavior", we = /* @__PURE__ */ u(!1), dt = /* @__PURE__ */ u(!1), lo = Ft(Jt, dt), As = U(Jt), Rs = lo("disableConfirmation", () => {
  qe(!1);
}), Bs = lo("enableConfirmation", () => {
  qe(!0);
}), Ps = As("mount", () => {
  dt() || (qe(
    D() && B(Jt) || !1
  ), dt.set(!0));
});
function qe(t) {
  t !== we() && (d("web_app_setup_closing_behavior", { need_confirmation: t }), R(Jt, t), we.set(t));
}
function Ts() {
  dt.set(!1);
}
const Ji = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  disableConfirmation: Rs,
  enableConfirmation: Bs,
  isConfirmationEnabled: we,
  isMounted: dt,
  mount: Ps,
  unmount: Ts
}, Symbol.toStringTag, { value: "Module" })), _o = "web_app_invoke_custom_method", Yt = P("cloudStorage", _o), ks = M(_o), Os = Yt("deleteItem", (t, e) => {
  const n = Array.isArray(t) ? t : [t];
  return n.length ? tt("deleteStorageValues", { keys: n }, e).then() : g.resolve();
});
function Ds(t, e) {
  const n = Array.isArray(t) ? t : [t];
  return n.length ? tt("getStorageValues", { keys: n }, e).then((o) => {
    const r = Mt(
      Object.fromEntries(n.map((s) => [s, j()]))
    )()(o);
    return Array.isArray(t) ? r : r[t];
  }) : g.resolve(typeof t == "string" ? "" : {});
}
const xs = Yt("getItem", Ds), Ms = Yt("getKeys", (t) => tt("getStorageKeys", {}, t).then(er(j())())), Vs = Yt("setItem", (t, e, n) => tt("saveStorageValue", {
  key: t,
  value: e
}, n).then()), Yi = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  deleteItem: Os,
  getItem: xs,
  getKeys: Ms,
  isSupported: ks,
  setItem: Vs
}, Symbol.toStringTag, { value: "Module" })), Ct = "web_app_trigger_haptic_feedback", He = P("hapticFeedback", Ct), Is = M(Ct), Ns = He(
  "impactOccurred",
  (t) => {
    d(Ct, {
      type: "impact",
      impact_style: t
    });
  }
), Ls = He(
  "notificationOccurred",
  (t) => {
    d(Ct, {
      type: "notification",
      notification_type: t
    });
  }
), js = He(
  "selectionChanged",
  () => {
    d(Ct, { type: "selection_change" });
  }
), Qi = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  impactOccurred: Ns,
  isSupported: Is,
  notificationOccurred: Ls,
  selectionChanged: js
}, Symbol.toStringTag, { value: "Module" })), We = /* @__PURE__ */ u(void 0);
function I(t) {
  return /* @__PURE__ */ h(() => {
    const e = We();
    return e ? e[t] : void 0;
  });
}
const fo = I("authDate"), ho = I("canSendAfter"), $s = /* @__PURE__ */ h(() => {
  const t = fo(), e = ho();
  return e && t ? new Date(t.getTime() + e * 1e3) : void 0;
}), Us = I("chat"), qs = I("chatType"), Hs = I("chatInstance"), Ws = I("hash"), zs = I("queryId"), mo = /* @__PURE__ */ u(), Gs = I("receiver");
function Fs() {
  const t = G();
  We.set(t.initData), mo.set(t.initDataRaw);
}
const Js = I("startParam"), Ys = I("user"), Ki = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  authDate: fo,
  canSendAfter: ho,
  canSendAfterDate: $s,
  chat: Us,
  chatInstance: Hs,
  chatType: qs,
  hash: Ws,
  queryId: zs,
  raw: mo,
  receiver: Gs,
  restore: Fs,
  startParam: Js,
  state: We,
  user: Ys
}, Symbol.toStringTag, { value: "Module" }));
function Zi(t) {
  return Qo()(t);
}
const ze = "web_app_open_invoice", Qs = P("invoice", ze), Pt = /* @__PURE__ */ u(!1), Ks = M(ze);
async function bo(t, e, n) {
  if (Pt())
    throw new l(Ie, "An invoice is already opened");
  let o;
  if (e === "url") {
    const { hostname: r, pathname: s } = new URL(t, window.location.href);
    if (r !== "t.me")
      throw new l(Ve, `Link has unexpected hostname: ${r}`);
    const a = s.match(/^\/(\$|invoice\/)([A-Za-z0-9\-_=]+)$/);
    if (!a)
      throw new l(
        Qr,
        'Expected to receive a link with a pathname in format "/invoice/{slug}" or "/${slug}"'
      );
    [, , o] = a;
  } else
    o = t, n = e;
  return Pt.set(!0), x(ze, "invoice_closed", {
    ...n,
    params: { slug: o },
    capture: (r) => o === r.slug
  }).then((r) => r.status).finally(() => {
    Pt.set(!1);
  });
}
const Zs = Qs("open", bo), Xi = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  _open: bo,
  isOpened: Pt,
  isSupported: Ks,
  open: Zs
}, Symbol.toStringTag, { value: "Module" }));
function go(t) {
  const e = On(t);
  return Math.sqrt(
    [0.299, 0.587, 0.114].reduce((n, o, r) => {
      const s = parseInt(e.slice(1 + r * 2, 1 + (r + 1) * 2), 16);
      return n + s * s * o;
    }, 0)
  ) < 120;
}
const _t = /* @__PURE__ */ u(!1), Tt = /* @__PURE__ */ u(!1), q = /* @__PURE__ */ u({});
function E(t) {
  return /* @__PURE__ */ h(() => q()[t]);
}
const Xs = E("accentTextColor"), Ge = E("bgColor"), Fe = E("buttonColor"), wo = E("buttonTextColor"), yo = E("bottomBarBgColor"), ta = E("destructiveTextColor"), ea = E("headerBgColor"), na = E("hintColor"), oa = /* @__PURE__ */ h(() => {
  const { bgColor: t } = q();
  return !t || go(t);
}), ra = E("linkColor"), Nt = E("secondaryBgColor"), sa = E("sectionBgColor"), aa = E("sectionHeaderTextColor"), ia = E("sectionSeparatorColor"), ca = E("subtitleTextColor"), ua = E("textColor");
function J(t) {
  return /* @__PURE__ */ h(() => Je()[t]);
}
const st = /* @__PURE__ */ u({
  hasShineEffect: !1,
  isEnabled: !0,
  isLoaderVisible: !1,
  isVisible: !1,
  text: "Continue"
}), Je = /* @__PURE__ */ h(() => {
  const t = st();
  return {
    ...t,
    backgroundColor: t.backgroundColor || Fe() || "#2481cc",
    textColor: t.textColor || wo() || "#ffffff"
  };
}), ft = /* @__PURE__ */ u(!1), pa = J("backgroundColor"), la = J("hasShineEffect"), da = J("isEnabled"), _a = J("isLoaderVisible"), fa = J("isVisible"), ha = J("text"), ma = J("textColor"), ba = "web_app_setup_main_button", Eo = "main_button_pressed", Qt = "mainButton", Ye = U(Qt), ga = Ft(Qt, ft), wa = Ye("mount", () => {
  if (!ft()) {
    const t = D() && B(Qt);
    t && st.set(t), ft.set(!0);
  }
}), ya = Ye(
  "onClick",
  (t) => v(Eo, t)
), Ea = Ye(
  "offClick",
  (t) => {
    F(Eo, t);
  }
), Sa = ga(
  "setParams",
  (t) => {
    st.set({
      ...st(),
      ...Object.fromEntries(
        Object.entries(t).filter(([, n]) => n !== void 0)
      )
    }), R(Qt, st());
    const e = Je();
    e.text && d(ba, {
      color: e.backgroundColor,
      has_shine_effect: e.hasShineEffect,
      is_active: e.isEnabled,
      is_progress_visible: e.isLoaderVisible,
      is_visible: e.isVisible,
      text: e.text,
      text_color: e.textColor
    });
  }
);
function va() {
  ft.set(!1);
}
const tc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  backgroundColor: pa,
  hasShineEffect: la,
  isEnabled: da,
  isLoaderVisible: _a,
  isMounted: ft,
  isVisible: fa,
  mount: wa,
  offClick: Ea,
  onClick: ya,
  setParams: Sa,
  state: Je,
  text: ha,
  textColor: ma,
  unmount: va
}, Symbol.toStringTag, { value: "Module" }));
function Qe() {
  throw new l(
    ts,
    "CSS variables are already bound"
  );
}
function Ca(t) {
  return Xo()(t);
}
const Kt = "themeParams", So = "theme_changed", Aa = U(Kt), Ra = Ft(Kt, _t), Ba = Ra(
  "bindCssVars",
  (t) => {
    Tt() && Qe(), t || (t = (o) => `--tg-theme-${Pe(o)}`);
    function e(o) {
      Object.entries(q()).forEach(([r, s]) => {
        s && o(r, s);
      });
    }
    function n() {
      e((o, r) => {
        Te(t(o), r);
      });
    }
    return n(), q.sub(n), Tt.set(!0), () => {
      e(ke), q.unsub(n), Tt.set(!1);
    };
  }
), vo = Aa("mount", () => {
  _t() || (v(So, Co), q.set(
    D() && B(Kt) || G().themeParams
  ), _t.set(!0));
}), Co = (t) => {
  const e = Ca(t.theme_params);
  q.set(e), R(Kt, e);
};
function Pa() {
  F(So, Co), _t.set(!1);
}
// @__NO_SIDE_EFFECTS__
function Ao(t) {
  return /* @__PURE__ */ h(() => {
    const e = t();
    return ct(e) ? e : e === "bg_color" ? Ge() : Nt();
  });
}
const ht = /* @__PURE__ */ u("bg_color"), Ke = /* @__PURE__ */ Ao(ht), mt = /* @__PURE__ */ u("bottom_bar_bg_color"), Ze = /* @__PURE__ */ h(() => {
  const t = mt();
  return ct(t) ? t : t === "bottom_bar_bg_color" ? yo() || Nt() : t === "secondary_bg_color" ? Nt() : Ge();
}), bt = /* @__PURE__ */ u("bg_color"), Ro = /* @__PURE__ */ Ao(bt), gt = /* @__PURE__ */ u(!1), kt = /* @__PURE__ */ u(!1), Ta = /* @__PURE__ */ h(() => {
  const t = Ke();
  return t ? go(t) : !1;
}), Bo = /* @__PURE__ */ h(() => ({
  backgroundColor: ht(),
  bottomBarColor: mt(),
  headerColor: bt()
})), ye = "web_app_set_background_color", Ee = "web_app_set_bottom_bar_color", Ot = "web_app_set_header_color", At = "miniApp", Xe = {
  any: [
    ye,
    Ee,
    Ot
  ]
}, ka = /* @__PURE__ */ h(() => Xe.any.some((t) => z(t, L()))), Po = U(At), Oa = P(At, Xe), Zt = et(At, gt, Xe), Da = Zt(
  "bindCssVars",
  (t) => {
    kt() && Qe();
    const [e, n] = Z();
    function o(r, s) {
      function a() {
        Te(r, s() || null);
      }
      a(), e(s.sub(a), ke.bind(null, r));
    }
    return t || (t = (r) => `--tg-${Pe(r)}`), o(t("bgColor"), Ke), o(t("bottomBarColor"), Ze), o(t("headerColor"), Ro), e(() => {
      kt.set(!1);
    }), kt.set(!0), n;
  }
), xa = Po("close", (t) => {
  d("web_app_close", { return_back: t });
}), Ma = Oa(
  "mount",
  () => {
    if (!gt()) {
      const t = D() && B(At);
      vo(), To.ifAvailable(t ? t.backgroundColor : "bg_color"), ko.ifAvailable(t ? t.bottomBarColor : "bottom_bar_bg_color"), Oo.ifAvailable(t ? t.headerColor : "bg_color"), gt.set(!0);
    }
  }
), Va = Po("ready", () => {
  d("web_app_ready");
});
function tn() {
  R(At, Bo());
}
const To = Zt(
  "setBackgroundColor",
  (t) => {
    t !== ht() && (d(ye, { color: t }), ht.set(t), tn());
  },
  ye
), ko = Zt(
  "setBottomBarColor",
  (t) => {
    t !== mt() && (d(Ee, { color: t }), mt.set(t), tn());
  },
  Ee
), Oo = Zt(
  "setHeaderColor",
  (t) => {
    t !== bt() && (d(Ot, ct(t) ? { color: t } : { color_key: t }), bt.set(t), tn());
  },
  Ot,
  {
    rgb: [Ot, "color", ct]
  }
);
function Ia() {
  gt.set(!1);
}
const ec = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  backgroundColor: ht,
  backgroundColorRGB: Ke,
  bindCssVars: Da,
  bottomBarColor: mt,
  bottomBarColorRGB: Ze,
  close: xa,
  headerColor: bt,
  headerColorRGB: Ro,
  isCssVarsBound: kt,
  isDark: Ta,
  isMounted: gt,
  isSupported: ka,
  mount: Ma,
  ready: Va,
  setBackgroundColor: To,
  setBottomBarColor: ko,
  setHeaderColor: Oo,
  state: Bo,
  unmount: Ia
}, Symbol.toStringTag, { value: "Module" }));
function Na(t) {
  const e = t.message.trim(), n = (t.title || "").trim(), o = t.buttons || [];
  if (n.length > 64)
    throw new l(nt, `Invalid title: ${n}`);
  if (!e || e.length > 256)
    throw new l(nt, `Invalid message: ${e}`);
  if (o.length > 3)
    throw new l(nt, `Invalid buttons count: ${o.length}`);
  return {
    title: n,
    message: e,
    buttons: o.length ? o.map((r, s) => {
      const a = r.id || "";
      if (a.length > 64)
        throw new l(nt, `Button with index ${s} has invalid id: ${a}`);
      if (!r.type || r.type === "default" || r.type === "destructive") {
        const i = r.text.trim();
        if (!i || i.length > 64)
          throw new l(nt, `Button with index ${s} has invalid text: ${i}`);
        return { type: r.type, text: i, id: a };
      }
      return { type: r.type, id: a };
    }) : [{ type: "close", id: "" }]
  };
}
const en = "web_app_open_popup", La = P("popup", en), Dt = /* @__PURE__ */ u(!1), ja = M(en), $a = La(
  "open",
  async (t) => {
    if (Dt())
      throw new l(Ie, "A popup is already opened");
    Dt.set(!0);
    try {
      const { button_id: e = null } = await x(en, "popup_closed", {
        ...t,
        params: Na(t)
      });
      return e;
    } finally {
      Dt.set(!1);
    }
  }
), nc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  isOpened: Dt,
  isSupported: ja,
  open: $a
}, Symbol.toStringTag, { value: "Module" })), Ua = "web_app_close_scan_qr_popup", nn = "web_app_open_scan_qr_popup", qa = "scan_qr_popup_closed", Ha = "qr_text_received", Do = P("qrScanner", nn), Se = Do("close", () => {
  Q.set(!1), d(Ua);
}), Q = /* @__PURE__ */ u(!1), Wa = M(nn);
function za(t) {
  return g.withFn((e) => {
    if (Q())
      throw new l(Ie, "The QR Scanner is already opened");
    Q.set(!0), t || (t = {});
    const { onCaptured: n, text: o, capture: r } = t, [, s] = Z(
      // Whenever the scanner was closed for some reason (by a developer or a
      // user), we should resolve the promise with undefined.
      Q.sub(() => {
        a.resolve();
      }),
      // Whenever user closed the scanner, update the isOpened signal state.
      v(qa, () => {
        Q.set(!1);
      }),
      // Whenever some QR was scanned, we should check if it must be captured.
      v(Ha, (i) => {
        n ? n(i.data) : (!r || r(i.data)) && (a.resolve(i.data), Se());
      })
    ), a = new ot({ abortSignal: e }).catch(Se).finally(s);
    return (t.postEvent || d)(nn, { text: o }), a;
  }, t);
}
const Ga = Do("open", za), oc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  close: Se,
  isOpened: Q,
  isSupported: Wa,
  open: Ga
}, Symbol.toStringTag, { value: "Module" }));
function H(t) {
  return /* @__PURE__ */ h(() => on()[t]);
}
const at = /* @__PURE__ */ u({
  hasShineEffect: !1,
  isEnabled: !0,
  isLoaderVisible: !1,
  isVisible: !1,
  position: "left",
  text: "Cancel"
}), on = /* @__PURE__ */ h(() => {
  const t = at();
  return {
    ...t,
    backgroundColor: t.backgroundColor || Ze() || "#000000",
    textColor: t.textColor || Fe() || "#2481cc"
  };
}), wt = /* @__PURE__ */ u(!1), Fa = H("backgroundColor"), Ja = H("hasShineEffect"), Ya = H("isEnabled"), Qa = H("isLoaderVisible"), Ka = H("isVisible"), Za = H("position"), Xa = H("text"), ti = H("textColor"), Xt = "web_app_setup_secondary_button", xo = "secondary_button_pressed", te = "secondaryButton", rn = P(te, Xt), ei = et(te, wt, Xt), ni = M(Xt), oi = rn("mount", () => {
  if (!wt()) {
    const t = D() && B(te);
    t && at.set(t), wt.set(!0);
  }
}), ri = rn(
  "onClick",
  (t) => v(xo, t)
), si = rn(
  "offClick",
  (t) => {
    F(xo, t);
  }
), ai = ei(
  "setParams",
  (t) => {
    at.set({
      ...at(),
      ...Object.fromEntries(
        Object.entries(t).filter(([, n]) => n !== void 0)
      )
    }), R(te, at());
    const e = on();
    e.text && d(Xt, {
      color: e.backgroundColor,
      has_shine_effect: e.hasShineEffect,
      is_active: e.isEnabled,
      is_progress_visible: e.isLoaderVisible,
      is_visible: e.isVisible,
      position: e.position,
      text: e.text,
      text_color: e.textColor
    });
  }
);
function ii() {
  wt.set(!1);
}
const rc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  backgroundColor: Fa,
  hasShineEffect: Ja,
  isEnabled: Ya,
  isLoaderVisible: Qa,
  isMounted: wt,
  isSupported: ni,
  isVisible: Ka,
  mount: oi,
  offClick: si,
  onClick: ri,
  position: Za,
  setParams: ai,
  state: on,
  text: Xa,
  textColor: ti,
  unmount: ii
}, Symbol.toStringTag, { value: "Module" })), ee = "web_app_setup_settings_button", Mo = "settings_button_pressed", ne = "settingsButton", ve = /* @__PURE__ */ u(!1), yt = /* @__PURE__ */ u(!1), ci = M(ee), sn = P(ne, ee), Vo = et(ne, yt, ee), ui = Vo("hide", () => {
  an(!1);
}), pi = sn("mount", () => {
  yt() || (an(D() && B(ne) || !1), yt.set(!0));
});
function an(t) {
  t !== ve() && (d(ee, { is_visible: t }), R(ne, t), ve.set(t));
}
const li = sn(
  "onClick",
  (t) => v(Mo, t)
), di = sn(
  "offClick",
  (t) => {
    F(Mo, t);
  }
), _i = Vo("show", () => {
  an(!0);
});
function fi() {
  yt.set(!1);
}
const sc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hide: ui,
  isMounted: yt,
  isSupported: ci,
  isVisible: ve,
  mount: pi,
  offClick: di,
  onClick: li,
  show: _i,
  unmount: fi
}, Symbol.toStringTag, { value: "Module" })), oe = "web_app_setup_swipe_behavior", re = "swipeBehavior", Et = /* @__PURE__ */ u(!1), hi = M(oe), Ce = /* @__PURE__ */ u(!0), mi = P(re, oe), Io = et(re, Et, oe), bi = Io("disableVertical", () => {
  cn(!1);
}), gi = Io("enableVertical", () => {
  cn(!0);
}), wi = mi("mount", () => {
  Et() || (cn(
    D() && B(re) || !1,
    !0
  ), Et.set(!0));
});
function cn(t, e) {
  (t !== Ce() || e) && (d(oe, { allow_vertical_swipe: t }), R(re, t), Ce.set(t));
}
function yi() {
  Et.set(!1);
}
const ac = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  disableVertical: bi,
  enableVertical: gi,
  isMounted: Et,
  isSupported: hi,
  isVerticalEnabled: Ce,
  mount: wi,
  unmount: yi
}, Symbol.toStringTag, { value: "Module" })), ic = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  accentTextColor: Xs,
  backgroundColor: Ge,
  bindCssVars: Ba,
  bottomBarBgColor: yo,
  buttonColor: Fe,
  buttonTextColor: wo,
  destructiveTextColor: ta,
  headerBackgroundColor: ea,
  hintColor: na,
  isCssVarsBound: Tt,
  isDark: oa,
  isMounted: _t,
  linkColor: ra,
  mount: vo,
  secondaryBackgroundColor: Nt,
  sectionBackgroundColor: sa,
  sectionHeaderTextColor: aa,
  sectionSeparatorColor: ia,
  state: q,
  subtitleTextColor: ca,
  textColor: ua,
  unmount: Pa
}, Symbol.toStringTag, { value: "Module" })), k = /* @__PURE__ */ u({
  height: 0,
  width: 0,
  isExpanded: !1,
  stableHeight: 0
}), se = /* @__PURE__ */ u(!1), xt = /* @__PURE__ */ u(!1), No = /* @__PURE__ */ u(!1), Lo = /* @__PURE__ */ u(void 0);
function ae(t) {
  return /* @__PURE__ */ h(() => k()[t]);
}
const Ei = ae("height"), Si = ae("isExpanded"), vi = /* @__PURE__ */ h(() => {
  const t = k();
  return t.height === t.stableHeight;
}), Ci = ae("stableHeight"), Ai = ae("width");
function Ri(t) {
  return x("web_app_request_viewport", "viewport_changed", t).then((e) => ({
    height: e.height,
    width: e.width,
    isExpanded: e.is_expanded,
    isStable: e.is_state_stable
  }));
}
const Lt = "viewport", jo = U(Lt), Bi = Ft(Lt, se), Pi = Bi(
  "bindCssVars",
  (t) => {
    xt() && Qe(), t || (t = (o) => `--tg-viewport-${Pe(o)}`);
    const e = ["height", "width", "stableHeight"];
    function n() {
      e.forEach((o) => {
        Te(t(o), `${k()[o]}px`);
      });
    }
    return n(), k.sub(n), xt.set(!0), () => {
      e.forEach(ke), k.unsub(n), xt.set(!1);
    };
  }
), Ti = jo("expand", () => {
  d("web_app_expand");
}), ki = jo(
  "mount",
  /* @__PURE__ */ ao(
    Lt,
    (t) => {
      const e = D() && B(Lt);
      if (e)
        return e;
      if ([
        "macos",
        "tdesktop",
        "unigram",
        "webk",
        "weba",
        "web"
      ].includes(G().platform)) {
        const n = window;
        return {
          isExpanded: !0,
          height: n.innerHeight,
          width: n.innerWidth,
          stableHeight: n.innerHeight
        };
      }
      return t.timeout || (t.timeout = 1e3), Ri(t).then((n) => ({
        height: n.height,
        isExpanded: n.isExpanded,
        stableHeight: n.isStable ? n.height : k().stableHeight,
        width: n.width
      }));
    },
    (t) => {
      v("viewport_changed", $o), Uo(t);
    },
    { isMounted: se, isMounting: No, mountError: Lo }
  )
), $o = (t) => {
  Uo({
    height: t.height,
    isExpanded: t.is_expanded,
    stableHeight: t.is_state_stable ? t.height : k().stableHeight,
    width: t.width
  });
};
function Uo(t) {
  k.set({
    isExpanded: t.isExpanded,
    height: le(t.height),
    width: le(t.width),
    stableHeight: le(t.stableHeight)
  }), R("viewport", k());
}
function le(t) {
  return Math.max(t, 0);
}
function Oi() {
  F("viewport_changed", $o), se.set(!1);
}
const cc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bindCssVars: Pi,
  expand: Ti,
  height: Ei,
  isCssVarsBound: xt,
  isExpanded: Si,
  isMounted: se,
  isMounting: No,
  isStable: vi,
  mount: ki,
  mountError: Lo,
  stableHeight: Ci,
  state: k,
  unmount: Oi,
  width: Ai
}, Symbol.toStringTag, { value: "Module" })), Di = U(), uc = Di(
  "openLink",
  (t, e) => {
    if (typeof t == "string")
      try {
        t = new URL(t);
      } catch (n) {
        throw new l(Ve, `"${t.toString()}" is invalid URL`, n);
      }
    e || (e = {}), d("web_app_open_link", {
      url: t.toString(),
      try_browser: e.tryBrowser,
      try_instant_view: e.tryInstantView
    });
  }
), wn = "web_app_open_tg_link", xi = U(), Mi = xi(
  "openTelegramLink",
  (t) => {
    const e = t.toString();
    if (!e.match(/^https:\/\/t.me\/.+/))
      throw new l(Ve, `"${e}" is invalid URL`);
    if (!z(wn, L())) {
      window.location.href = e;
      return;
    }
    t = new URL(t), d(wn, { path_full: t.pathname + t.search });
  }
), Vi = U(), pc = Vi(
  "shareURL",
  (t, e) => {
    Mi(
      "https://t.me/share/url?" + new URLSearchParams({ url: t, text: e || "" }).toString().replace(/\+/g, "%20")
    );
  }
), Ae = "web_app_request_phone", de = /* @__PURE__ */ u(!1), Ii = /* @__PURE__ */ V(
  "requestPhoneAccess",
  (t) => {
    if (de())
      throw new l(jt, "Phone access request is currently in progress");
    return de.set(!0), x(Ae, "phone_requested", t).then((e) => e.status).finally(() => {
      de.set(!1);
    });
  },
  {
    isSupported: Ae
  }
);
function yn(t) {
  return t || (t = {}), tt("getRequestedContact", {}, {
    ...t,
    timeout: t.timeout || 5e3
  }).then(
    kn({
      contact: Mt({
        userId: ["user_id", Vt()],
        phoneNumber: ["phone_number", j()],
        firstName: ["first_name", j()],
        lastName: ["last_name", j(!0)]
      })(),
      authDate: ["auth_date", Re()],
      hash: j()
    })()
  );
}
const lc = /* @__PURE__ */ V(
  "requestContact",
  (t) => g.withFn(
    async (e) => {
      const n = { abortSignal: e };
      try {
        return await yn(n);
      } catch {
      }
      if (await Ii(n) !== "sent")
        throw new l(Zr, "User denied access");
      let o = 50;
      for (; !e.aborted; ) {
        try {
          return await yn(n);
        } catch {
        }
        await Er(o), o += 50;
      }
      return null;
    },
    t
  ),
  {
    isSupported: Ae
  }
), En = "web_app_request_write_access", _e = /* @__PURE__ */ u(!1), dc = /* @__PURE__ */ V(
  "requestWriteAccess",
  (t) => {
    if (_e())
      throw new l(jt, "Write access request is currently in progress");
    return _e.set(!0), x(En, "write_access_requested", t).then((e) => e.status).finally(() => {
      _e.set(!1);
    });
  },
  {
    isSupported: En
  }
), _c = /* @__PURE__ */ V(
  "getCurrentTime",
  (t) => tt("getCurrentTime", {}, t).then(Re()),
  {
    isSupported: "web_app_invoke_custom_method"
  }
), Sn = "web_app_read_text_from_clipboard", fc = /* @__PURE__ */ V(
  "readTextFromClipboard",
  (t) => {
    const e = oo();
    return x(Sn, "clipboard_text_received", {
      ...t,
      params: { req_id: e },
      capture: eo(e)
    }).then(({ data: n = null }) => n);
  },
  {
    isSupported: Sn
  }
), hc = /* @__PURE__ */ V(
  "sendData",
  (t) => {
    const { size: e } = new Blob([t]);
    if (!e || e > 4096)
      throw new l(Kr, e ? "Maximum size of data to send is 4096 bytes" : "Attempted to send empty data");
    d("web_app_data_send", { data: t });
  }
), vn = "web_app_share_to_story", mc = /* @__PURE__ */ V(
  "shareStory",
  (t, e) => {
    e || (e = {}), d(vn, {
      text: e.text,
      media_url: t,
      widget_link: e.widgetLink
    });
  },
  { isSupported: vn }
), Cn = "web_app_switch_inline_query", bc = /* @__PURE__ */ V(
  "switchInlineQuery",
  (t, e) => {
    d(Cn, {
      query: t,
      chat_types: e || []
    });
  },
  {
    isSupported: [Cn, {
      fn: () => !!G().botInline,
      error: "Mini App should be ran in Bot inline mode"
    }]
  }
);
function gc(t) {
  try {
    return { result: t() };
  } catch (e) {
    return { error: e };
  }
}
function wc(t) {
  Yr(t), jr();
  const [e, n] = Z(
    v("reload_iframe", () => {
      d("iframe_will_reload"), window.location.reload();
    }),
    $r
  ), { acceptCustomStyles: o = !0 } = t || {};
  if (o) {
    const r = document.createElement("style");
    r.id = "telegram-custom-styles", document.head.appendChild(r), e(
      v("set_custom_style", (s) => {
        r.innerHTML = s;
      }),
      () => {
        document.head.removeChild(r);
      }
    );
  }
  return d("iframe_ready", { reload_supported: !0 }), n;
}
const yc = G;
function Ec(t) {
  const e = qo(t()), n = t.sub((o) => {
    e.value = o;
  });
  return Ho(n), Wo(e);
}
export {
  Jr as $createRequestId,
  Ar as $debug,
  no as $postEvent,
  xr as $targetOrigin,
  L as $version,
  g as CancelablePromise,
  zn as ERR_ABORTED,
  Zr as ERR_ACCESS_DENIED,
  Xr as ERR_ALREADY_MOUNTING,
  Ie as ERR_ALREADY_OPENED,
  jt as ERR_ALREADY_REQUESTING,
  Gn as ERR_CANCELED,
  ts as ERR_CSS_VARS_ALREADY_BOUND,
  Dr as ERR_CUSTOM_METHOD_ERR_RESPONSE,
  Kr as ERR_DATA_INVALID_SIZE,
  Qr as ERR_INVALID_SLUG,
  Ve as ERR_INVALID_URL,
  Go as ERR_INVALID_VALUE,
  Or as ERR_METHOD_PARAMETER_UNSUPPORTED,
  Tr as ERR_METHOD_UNSUPPORTED,
  es as ERR_NOT_AVAILABLE,
  ns as ERR_NOT_INITIALIZED,
  os as ERR_NOT_MOUNTED,
  mn as ERR_NOT_SUPPORTED,
  Bn as ERR_PARSE,
  nt as ERR_POPUP_INVALID_PARAMS,
  kr as ERR_RETRIEVE_LP_FAILED,
  Fn as ERR_TIMED_OUT,
  Jo as ERR_UNEXPECTED_TYPE,
  Fo as ERR_UNEXPECTED_VALUE,
  Kn as ERR_UNKNOWN_ENV,
  l as TypedError,
  he as addEventListener,
  ws as authenticateBiometry,
  Gi as backButton,
  Da as bindMiniAppCssVars,
  Ba as bindThemeParamsCssVars,
  Pi as bindViewportCssVars,
  Fi as biometry,
  co as biometryMountError,
  Ht as biometryState,
  fe as classNames,
  xa as closeMiniApp,
  Se as closeQrScanner,
  Ji as closingBehavior,
  Yi as cloudStorage,
  Ur as compareVersions,
  qr as createPostEvent,
  jr as defineEventHandlers,
  Os as deleteCloudStorageItem,
  ke as deleteCssVar,
  Rs as disableClosingConfirmation,
  bi as disableVerticalSwipes,
  be as emitMiniAppsEvent,
  Bs as enableClosingConfirmation,
  gi as enableVerticalSwipes,
  Ti as expandViewport,
  xs as getCloudStorageItem,
  Ms as getCloudStorageKeys,
  _c as getCurrentTime,
  Qi as hapticFeedback,
  Ns as hapticFeedbackImpactOccurred,
  Ls as hapticFeedbackNotificationOccurred,
  js as hapticFeedbackSelectionChanged,
  ss as hideBackButton,
  ui as hideSettingsButton,
  wc as init,
  Ki as initData,
  fo as initDataAuthDate,
  ho as initDataCanSendAfter,
  $s as initDataCanSendAfterDate,
  Us as initDataChat,
  Hs as initDataChatInstance,
  qs as initDataChatType,
  Ws as initDataHash,
  zs as initDataQueryId,
  mo as initDataRaw,
  Gs as initDataReceiver,
  Js as initDataStartParam,
  We as initDataState,
  Ys as initDataUser,
  Xi as invoice,
  Hr as invokeCustomMethod,
  Ui as isAbortError,
  Rt as isAuthenticatingBiometry,
  lt as isBackButtonMounted,
  rs as isBackButtonSupported,
  ge as isBackButtonVisible,
  Wt as isBiometryMounted,
  io as isBiometryMounting,
  ms as isBiometrySupported,
  qi as isCanceledError,
  dt as isClosingBehaviorMounted,
  we as isClosingConfirmationEnabled,
  ks as isCloudStorageSupported,
  go as isColorDark,
  Is as isHapticFeedbackSupported,
  br as isIframe,
  Pt as isInvoiceOpened,
  Ks as isInvoiceSupported,
  da as isMainButtonEnabled,
  _a as isMainButtonLoaderVisible,
  ft as isMainButtonMounted,
  fa as isMainButtonVisible,
  kt as isMiniAppCssVarsBound,
  Ta as isMiniAppDark,
  gt as isMiniAppMounted,
  ka as isMiniAppSupported,
  Dt as isPopupOpened,
  ja as isPopupSupported,
  Q as isQrScannerOpened,
  Wa as isQrScannerSupported,
  ct as isRGB,
  Ko as isRGBShort,
  Dn as isRecord,
  Bt as isRequestingBiometryAccess,
  de as isRequestingPhoneAccess,
  _e as isRequestingWriteAccess,
  bn as isSSR,
  Ya as isSecondaryButtonEnabled,
  Qa as isSecondaryButtonLoaderVisible,
  wt as isSecondaryButtonMounted,
  ni as isSecondaryButtonSupported,
  Ka as isSecondaryButtonVisible,
  yt as isSettingsButtonMounted,
  ci as isSettingsButtonSupported,
  ve as isSettingsButtonVisible,
  Et as isSwipeBehaviorMounted,
  hi as isSwipeBehaviorSupported,
  fn as isTMA,
  Tt as isThemeParamsCssVarsBound,
  oa as isThemeParamsDark,
  _t as isThemeParamsMounted,
  $i as isTimeoutError,
  Ce as isVerticalSwipesEnabled,
  xt as isViewportCssVarsBound,
  Si as isViewportExpanded,
  se as isViewportMounted,
  No as isViewportMounting,
  vi as isViewportStable,
  tc as mainButton,
  pa as mainButtonBackgroundColor,
  la as mainButtonHasShineEffect,
  Je as mainButtonState,
  ha as mainButtonText,
  ma as mainButtonTextColor,
  ji as mergeClassNames,
  ec as miniApp,
  ht as miniAppBackgroundColor,
  mt as miniAppBottomBarColor,
  Ze as miniAppBottomBarColorRGB,
  bt as miniAppHeaderColor,
  Ro as miniAppHeaderColorRGB,
  Va as miniAppReady,
  Bo as miniAppState,
  Hi as mockTelegramEnv,
  as as mountBackButton,
  Ss as mountBiometry,
  Ps as mountClosingBehavior,
  wa as mountMainButton,
  Ma as mountMiniApp,
  oi as mountSecondaryButton,
  pi as mountSettingsButton,
  wi as mountSwipeBehavior,
  vo as mountThemeParams,
  ki as mountViewport,
  F as off,
  cs as offBackButtonClick,
  Ea as offMainButtonClick,
  si as offSecondaryButtonClick,
  di as offSettingsButtonClick,
  v as on,
  is as onBackButtonClick,
  ya as onMainButtonClick,
  ri as onSecondaryButtonClick,
  li as onSettingsButtonClick,
  ys as openBiometrySettings,
  Zs as openInvoice,
  uc as openLink,
  $a as openPopup,
  Ga as openQrScanner,
  Mi as openTelegramLink,
  Zi as parseInitData,
  Ca as parseThemeParams,
  nc as popup,
  De as postEvent,
  oc as qrScanner,
  fc as readTextFromClipboard,
  $r as removeEventHandlers,
  xe as request,
  ds as requestBiometry,
  Es as requestBiometryAccess,
  lc as requestContact,
  Ii as requestPhoneAccess,
  Ri as requestViewport,
  dc as requestWriteAccess,
  Fs as restoreInitData,
  G as retrieveLaunchParams,
  gc as safeCall,
  rc as secondaryButton,
  Fa as secondaryButtonBackgroundColor,
  Ja as secondaryButtonHasShineEffect,
  Za as secondaryButtonPosition,
  on as secondaryButtonState,
  Xa as secondaryButtonText,
  ti as secondaryButtonTextColor,
  hc as sendData,
  Li as serializeLaunchParams,
  tr as serializeThemeParams,
  Vs as setCloudStorageItem,
  Te as setCssVar,
  Sa as setMainButtonParams,
  To as setMiniAppBackgroundColor,
  ko as setMiniAppBottomBarColor,
  Oo as setMiniAppHeaderColor,
  ai as setSecondaryButtonParams,
  sc as settingsButton,
  mc as shareStory,
  pc as shareURL,
  us as showBackButton,
  _i as showSettingsButton,
  Wi as subscribe,
  z as supports,
  ac as swipeBehavior,
  bc as switchInlineQuery,
  ic as themeParams,
  Xs as themeParamsAccentTextColor,
  Ge as themeParamsBackgroundColor,
  yo as themeParamsBottomBarBgColor,
  Fe as themeParamsButtonColor,
  wo as themeParamsButtonTextColor,
  ta as themeParamsDestructiveTextColor,
  ea as themeParamsHeaderBackgroundColor,
  na as themeParamsHintColor,
  ra as themeParamsLinkColor,
  Nt as themeParamsSecondaryBackgroundColor,
  sa as themeParamsSectionBackgroundColor,
  aa as themeParamsSectionHeaderTextColor,
  ia as themeParamsSectionSeparatorColor,
  q as themeParamsState,
  ca as themeParamsSubtitleTextColor,
  ua as themeParamsTextColor,
  On as toRGB,
  Tn as toRecord,
  ps as unmountBackButton,
  vs as unmountBiometry,
  Ts as unmountClosingBehavior,
  va as unmountMainButton,
  Ia as unmountMiniApp,
  ii as unmountSecondaryButton,
  fi as unmountSettingsButton,
  yi as unmountSwipeBehavior,
  Pa as unmountThemeParams,
  Oi as unmountViewport,
  zi as unsubscribe,
  Cs as updateBiometryToken,
  yc as useLaunchParams,
  Ec as useSignal,
  cc as viewport,
  Ei as viewportHeight,
  Lo as viewportMountError,
  Ci as viewportStableHeight,
  k as viewportState,
  Ai as viewportWidth
};
//# sourceMappingURL=index.js.map
